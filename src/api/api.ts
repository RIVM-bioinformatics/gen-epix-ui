/* eslint-disable */
// @ts-nocheck
/**
 * Gen-EpiX casedb
 * The casedb app manages data of cases of a disease.
 *
 * The version of the OpenAPI document: 7.1.1
 * Contact: ids-bioinformatics@rivm.nl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiPermission
 */
export interface ApiPermission {
    /**
     * 
     * @type {CommandName}
     * @memberof ApiPermission
     */
    'command_name': CommandName;
    /**
     * 
     * @type {PermissionType}
     * @memberof ApiPermission
     */
    'permission_type': PermissionType;
}


/**
 * A protocol used for assembling sequencing reads into a sequence.  An assembly protocol is immutable: once created, it cannot be deleted and it should not be semantically updated. As such, assembly protocol IDs can safely be referenced in other models and outside of the application.    PARENT CLASS DOCUMENTATION   ProtocolMixin:  Mixin class to add protocol related fields to a model.
 * @export
 * @interface AssemblyProtocol
 */
export interface AssemblyProtocol {
    /**
     * The code of the protocol
     * @type {string}
     * @memberof AssemblyProtocol
     */
    'code': string;
    /**
     * The name of the protocol
     * @type {string}
     * @memberof AssemblyProtocol
     */
    'name': string;
    /**
     * The version of the protocol
     * @type {string}
     * @memberof AssemblyProtocol
     */
    'version'?: string | null;
    /**
     * The description of the protocol
     * @type {string}
     * @memberof AssemblyProtocol
     */
    'description'?: string | null;
    /**
     * The properties of the protocol
     * @type {{ [key: string]: string; }}
     * @memberof AssemblyProtocol
     */
    'props'?: { [key: string]: string; };
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof AssemblyProtocol
     */
    'id'?: string | null;
    /**
     * Whether the assembly has a, potentially optional, manual curation step.
     * @type {boolean}
     * @memberof AssemblyProtocol
     */
    'has_manual_curation'?: boolean;
}
/**
 * 
 * @export
 * @ {string}
 */

export const AuthProtocol = {
    NONE: 'NONE',
    OAUTH2: 'OAUTH2',
    OIDC: 'OIDC'
} as const;

export type AuthProtocol = typeof AuthProtocol[keyof typeof AuthProtocol];


/**
 * A class representing a case.
 * @export
 * @interface Case
 */
export interface Case {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Case
     */
    'id'?: string | null;
    /**
     * A code for the case for further reference.
     * @type {string}
     * @memberof Case
     */
    'code'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof Case
     */
    'case_type'?: CaseType;
    /**
     * The ID of the subject. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'subject_id'?: string | null;
    /**
     * 
     * @type {EpiSubject}
     * @memberof Case
     */
    'subject'?: EpiSubject;
    /**
     * The ID of the data collection where the case was created. FOREIGN KEY
     * @type {string}
     * @memberof Case
     */
    'created_in_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof Case
     */
    'created_in_data_collection'?: DataCollection;
    /**
     * The number of cases that this case represents, if not one. This can be used to store aggregated cases (n>=0) as well as reference data (n=0).
     * @type {number}
     * @memberof Case
     */
    'count'?: number | null;
    /**
     * The datetime of the case used for sorting results, limiting results and statistics such as first and last case date. Normally re-calculated from the case content variables upon persisting. Default is the current datetime.
     * @type {string}
     * @memberof Case
     */
    'case_date'?: string;
    /**
     * The data content of the case as {case_type_col_id: str_value | None}. Only case type columns defined for the case type of the case should be present here, and if no value is present, the key should be omitted. None content values are allowed but will be removed upon serialization.
     * @type {{ [key: string]: string | null; }}
     * @memberof Case
     */
    'content': { [key: string]: string | null; };
}
/**
 * A number of unique cases intended for upload.    PARENT CLASS DOCUMENTATION   BaseBatchForUpload:  Base class for batches of ParentForUpload objects to be uploaded. A batch is intended as a single unit of work for an upload operation and as such to be processed atomically.  Additional validation: - All ParentForUpload objects must have unique IDs (if provided) - All ParentForUpload objects must have unique external identifiers
 * @export
 * @interface CaseBatchForUpload
 */
export interface CaseBatchForUpload {
    /**
     * The unique identifier for the upload batch.
     * @type {string}
     * @memberof CaseBatchForUpload
     */
    'id'?: string;
    /**
     * The UTC timestamp when the upload batch was created.
     * @type {string}
     * @memberof CaseBatchForUpload
     */
    'created_at'?: string;
    /**
     * The cases to be uploaded.
     * @type {Array<CaseForUpload>}
     * @memberof CaseBatchForUpload
     */
    'cases': Array<CaseForUpload>;
}
/**
 * The result of uploading a batch of cases.    PARENT CLASS DOCUMENTATION   BaseBatchUploadResult: Base class for upload results corresponding to a complete batch of objects uploaded. The names of the fields in any child class must be exactly identical to those in the corresponding BaseBatchForUpload child class.    PARENT CLASS DOCUMENTATION   UploadResult:  Represents the result of an upload operation, including upload status and logs.  Additional validation: - If the status is successful (NOT_FAILED), there must be no error log items. - If the status is failed, there must be at least one error log item.    PARENT CLASS DOCUMENTATION   UploadResult:  Represents the result of an upload operation, including upload status and logs.  Additional validation: - If the status is successful (NOT_FAILED), there must be no error log items. - If the status is failed, there must be at least one error log item.
 * @export
 * @interface CaseBatchUploadResult
 */
export interface CaseBatchUploadResult {
    /**
     * The unique identifier for the specific object instance that this result pertains to, if applicable. E.g. the object that was created or updated as part of the upload.
     * @type {string}
     * @memberof CaseBatchUploadResult
     */
    'id'?: string | null;
    /**
     * 
     * @type {UploadStatus}
     * @memberof CaseBatchUploadResult
     */
    'status'?: UploadStatus;
    /**
     * A list of log items capturing messages and events that occurred during the upload operation.
     * @type {Array<UploadLogItem>}
     * @memberof CaseBatchUploadResult
     */
    'logs'?: Array<UploadLogItem>;
    /**
     * The unique identifier for the upload batch that this result belongs to.
     * @type {string}
     * @memberof CaseBatchUploadResult
     */
    'batch_id'?: string;
    /**
     * The results of uploading the cases.
     * @type {Array<CaseUploadResult>}
     * @memberof CaseBatchUploadResult
     */
    'cases': Array<CaseUploadResult>;
}


/**
 * 
 * @export
 * @ {string}
 */

export const CaseClassification = {
    POSSIBLE: 'POSSIBLE',
    PROBABLE: 'PROBABLE',
    CONFIRMED: 'CONFIRMED'
} as const;

export type CaseClassification = typeof CaseClassification[keyof typeof CaseClassification];


/**
 * 
 * @export
 * @interface CaseDataCollectionLink
 */
export interface CaseDataCollectionLink {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'id'?: string | null;
    /**
     * The ID of the case. FOREIGN KEY
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'case_id': string;
    /**
     * 
     * @type {Case}
     * @memberof CaseDataCollectionLink
     */
    'case'?: Case;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof CaseDataCollectionLink
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseDataCollectionLink
     */
    'data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface CaseDataIssue
 */
export interface CaseDataIssue {
    /**
     * The ID of the case type column
     * @type {string}
     * @memberof CaseDataIssue
     */
    'case_type_col_id': string;
    /**
     * The value of the case type column
     * @type {string}
     * @memberof CaseDataIssue
     */
    'original_value': string | null;
    /**
     * The new value of the case type column after potential resolution. If not resolved, this will be None.
     * @type {string}
     * @memberof CaseDataIssue
     */
    'updated_value': string | null;
    /**
     * 
     * @type {DataIssueType}
     * @memberof CaseDataIssue
     */
    'data_issue_type': DataIssueType;
    /**
     * The code of the data issue
     * @type {string}
     * @memberof CaseDataIssue
     */
    'code': string;
    /**
     * The details of the data issue
     * @type {string}
     * @memberof CaseDataIssue
     */
    'message': string | null;
}


/**
 * A case intended for upload, together with any relevant associated data.    PARENT CLASS DOCUMENTATION   ParentForUpload: Represents a parent model for upload, where the term \"parent\" refers to a model that can have child models associated with it through a link. External identifiers can also be added here.  This class must be subclassed for specific parent models, adding the following fields: - A parent Parent|None field where the parent model that needs to be uploaded, if   any, will be put - For each child model type that can be associated with the parent, a \"children\"   list|None field that will contain the actual child models to be uploaded along with   the parent model. Metadata on the parent and child models, allowing introspection, must be provided through the class variables.  Additional validation: - NULL_ID in the id field is converted to None. - If both the ParentForUpload id and the contained Parent model id are provided,   they must match. - For each child model type, if the ParentForUpload id is provided, the parent ID   field in each child model must either be None/NULL_ID or match the ParentForUpload   id.    PARENT CLASS DOCUMENTATION   IsNewIdMixin:  Mixin that adds an is_new_id field to indicate whether the model instance is new and has an externally assigned ID rather than one assigned by the system. Assumes that the inheriting model also has an \'id\' field.  Additional validation: - If is_new_id is True, the model id field field may not be None or NULL_ID.    PARENT CLASS DOCUMENTATION   IsNewIdMixin:  Mixin that adds an is_new_id field to indicate whether the model instance is new and has an externally assigned ID rather than one assigned by the system. Assumes that the inheriting model also has an \'id\' field.  Additional validation: - If is_new_id is True, the model id field field may not be None or NULL_ID.
 * @export
 * @interface CaseForUpload
 */
export interface CaseForUpload {
    /**
     * Indicates whether the model instance is both new (not yet stored) and its ID is assigned outside the system, e.g. for having the same IDs between different environments.
     * @type {boolean}
     * @memberof CaseForUpload
     */
    'is_new_id'?: boolean;
    /**
     * The unique identifier for the Parent object. If NULL_ID is provided, it will be set to None.
     * @type {string}
     * @memberof CaseForUpload
     */
    'id'?: string | null;
    /**
     * External identifiers for the parent model, if any. Must be a unique values.
     * @type {Array<ExternalIdentifierForUpload>}
     * @memberof CaseForUpload
     */
    'external_identifiers'?: Array<ExternalIdentifierForUpload> | null;
    /**
     * 
     * @type {Case}
     * @memberof CaseForUpload
     */
    'case'?: Case;
    /**
     * The read sets to be uploaded and associated with the case. If None, this element is not taken into consideration during the upload. Must each be for a different case type column.
     * @type {Array<ReadSetForUpload>}
     * @memberof CaseForUpload
     */
    'read_sets'?: Array<ReadSetForUpload> | null;
    /**
     * The sequences to be uploaded and associated with the case. If None, this element is not taken into consideration during the upload. Must each be for a different case type column.
     * @type {Array<SeqForUpload>}
     * @memberof CaseForUpload
     */
    'seqs'?: Array<SeqForUpload> | null;
}
/**
 * 
 * @export
 * @interface CaseQuery
 */
export interface CaseQuery {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseQuery
     */
    'id'?: string | null;
    /**
     * The label for the query.
     * @type {string}
     * @memberof CaseQuery
     */
    'label'?: string | null;
    /**
     * The ID of the case type that the cases must belong to.
     * @type {string}
     * @memberof CaseQuery
     */
    'case_type_id': string;
    /**
     * The IDs of the case set(s) that the case must belong to. Not applied if not provided. All case sets must belong to the same case type as case_type_id.
     * @type {Array<string>}
     * @memberof CaseQuery
     */
    'case_set_ids'?: Array<string> | null;
    /**
     * 
     * @type {TypedDatetimeRangeFilter}
     * @memberof CaseQuery
     */
    'datetime_range_filter'?: TypedDatetimeRangeFilter;
    /**
     * 
     * @type {TypedCompositeFilter}
     * @memberof CaseQuery
     */
    'filter'?: TypedCompositeFilter;
}
/**
 * 
 * @export
 * @interface CaseQueryResult
 */
export interface CaseQueryResult {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseQueryResult
     */
    'id'?: string | null;
    /**
     * 
     * @type {CaseQuery}
     * @memberof CaseQueryResult
     */
    'case_query': CaseQuery;
    /**
     * The IDs of the cases matching the query, possibly limited by CaseSettings.read_max_n_cases. If limited, the most recent cases according to CaseSettings.stats_time_dim_id are returned
     * @type {Array<string>}
     * @memberof CaseQueryResult
     */
    'case_ids': Array<string>;
    /**
     * Whether the number of results was limited.
     * @type {boolean}
     * @memberof CaseQueryResult
     */
    'is_max_results_exceeded': boolean;
}
/**
 * Describes all the rights that a user has on one particular case, based on the data collections in which it is currently shared.    PARENT CLASS DOCUMENTATION   BaseCaseRights:  Base class describing all the rights that a user has on one particular item, based on the data collections in which it is currently shared.
 * @export
 * @interface CaseRights
 */
export interface CaseRights {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseRights
     */
    'id'?: string | null;
    /**
     * The ID of the data collection where the item was created
     * @type {string}
     * @memberof CaseRights
     */
    'created_in_data_collection_id': string;
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseRights
     */
    'case_type_id': string;
    /**
     * The IDs of the data collections in which the item is currently shared, including the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'data_collection_ids': Array<string>;
    /**
     * Whether the user has full access to the item, i.e. all rights on all data collections
     * @type {boolean}
     * @memberof CaseRights
     */
    'is_full_access': boolean;
    /**
     * The IDs of the data collections to which the item is allowed to be added
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'add_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which the item is allowed to be removed. If remove_data_collection_ids is equal to data_collection_ids, the item is allowed to be deleted
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'remove_data_collection_ids': Array<string>;
    /**
     * Whether the item can be deleted.
     * @type {boolean}
     * @memberof CaseRights
     */
    'can_delete': boolean;
    /**
     * The IDs of the data collections in which the item is currently shared, excluding the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'shared_in_data_collection_ids': Array<string>;
    /**
     * The ID of the case
     * @type {string}
     * @memberof CaseRights
     */
    'case_id': string;
    /**
     * The IDs of the case type columns that are allowed to be read for the case
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'read_case_type_col_ids': Array<string>;
    /**
     * The IDs of the case type columns that are allowed to be written for the case
     * @type {Array<string>}
     * @memberof CaseRights
     */
    'write_case_type_col_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface CaseSet
 */
export interface CaseSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSet
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseSet
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseSet
     */
    'case_type'?: CaseType;
    /**
     * The ID of the data collection where the case set was created. FOREIGN KEY
     * @type {string}
     * @memberof CaseSet
     */
    'created_in_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseSet
     */
    'created_in_data_collection'?: DataCollection;
    /**
     * The name of a case set, UNIQUE
     * @type {string}
     * @memberof CaseSet
     */
    'name': string;
    /**
     * The description of a case set
     * @type {string}
     * @memberof CaseSet
     */
    'description': string;
    /**
     * The datetime of the case set creation
     * @type {string}
     * @memberof CaseSet
     */
    'created_at'?: string;
    /**
     * The id of the category of the case set
     * @type {string}
     * @memberof CaseSet
     */
    'case_set_category_id': string;
    /**
     * 
     * @type {CaseSetCategory}
     * @memberof CaseSet
     */
    'case_set_category'?: CaseSetCategory;
    /**
     * The id of the status of the case set
     * @type {string}
     * @memberof CaseSet
     */
    'case_set_status_id': string;
    /**
     * 
     * @type {CaseSetStatus}
     * @memberof CaseSet
     */
    'case_set_status'?: CaseSetStatus;
}
/**
 * 
 * @export
 * @interface CaseSetCategory
 */
export interface CaseSetCategory {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSetCategory
     */
    'id'?: string | null;
    /**
     * The name of the case set category, UNIQUE
     * @type {string}
     * @memberof CaseSetCategory
     */
    'name': string;
    /**
     * The description of the case set category
     * @type {string}
     * @memberof CaseSetCategory
     */
    'description': string | null;
}
/**
 * 
 * @export
 * @interface CaseSetDataCollectionLink
 */
export interface CaseSetDataCollectionLink {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'id'?: string | null;
    /**
     * The ID of the case set. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'case_set_id': string;
    /**
     * 
     * @type {CaseSet}
     * @memberof CaseSetDataCollectionLink
     */
    'case_set'?: CaseSet;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetDataCollectionLink
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof CaseSetDataCollectionLink
     */
    'data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface CaseSetMember
 */
export interface CaseSetMember {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case set. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetMember
     */
    'case_set_id': string;
    /**
     * 
     * @type {CaseSet}
     * @memberof CaseSetMember
     */
    'case_set'?: CaseSet;
    /**
     * The ID of the case. FOREIGN KEY
     * @type {string}
     * @memberof CaseSetMember
     */
    'case_id': string;
    /**
     * 
     * @type {Case}
     * @memberof CaseSetMember
     */
    'case'?: Case;
    /**
     * 
     * @type {CaseClassification}
     * @memberof CaseSetMember
     */
    'classification'?: CaseClassification;
}


/**
 * Describes all the rights that a user has on one particular case set, based on the data collections in which it is currently shared.    PARENT CLASS DOCUMENTATION   BaseCaseRights:  Base class describing all the rights that a user has on one particular item, based on the data collections in which it is currently shared.
 * @export
 * @interface CaseSetRights
 */
export interface CaseSetRights {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSetRights
     */
    'id'?: string | null;
    /**
     * The ID of the data collection where the item was created
     * @type {string}
     * @memberof CaseSetRights
     */
    'created_in_data_collection_id': string;
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseSetRights
     */
    'case_type_id': string;
    /**
     * The IDs of the data collections in which the item is currently shared, including the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'data_collection_ids': Array<string>;
    /**
     * Whether the user has full access to the item, i.e. all rights on all data collections
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'is_full_access': boolean;
    /**
     * The IDs of the data collections to which the item is allowed to be added
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'add_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which the item is allowed to be removed. If remove_data_collection_ids is equal to data_collection_ids, the item is allowed to be deleted
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'remove_data_collection_ids': Array<string>;
    /**
     * Whether the item can be deleted.
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'can_delete': boolean;
    /**
     * The IDs of the data collections in which the item is currently shared, excluding the created_in_data_collection_id
     * @type {Array<string>}
     * @memberof CaseSetRights
     */
    'shared_in_data_collection_ids': Array<string>;
    /**
     * The ID of the case set
     * @type {string}
     * @memberof CaseSetRights
     */
    'case_set_id': string;
    /**
     * Whether the case set is allowed to be read
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'read_case_set': boolean;
    /**
     * Whether the case set is allowed to be written
     * @type {boolean}
     * @memberof CaseSetRights
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface CaseSetStatus
 */
export interface CaseSetStatus {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseSetStatus
     */
    'id'?: string | null;
    /**
     * The name of the case set status, UNIQUE
     * @type {string}
     * @memberof CaseSetStatus
     */
    'name': string;
    /**
     * The description of the case set status
     * @type {string}
     * @memberof CaseSetStatus
     */
    'description': string | null;
}
/**
 * PARENT CLASS DOCUMENTATION   Model: PARENT CLASS DOCUMENTATION   BaseModel: !!! abstract \"Usage Documentation\"     [Models](../concepts/models.md)  A base class for creating Pydantic models.  Attributes:     __class_vars__: The names of the class variables defined on the model.     __private_attributes__: Metadata about the private attributes of the model.     __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.      __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.     __pydantic_core_schema__: The core schema of the model.     __pydantic_custom_init__: Whether the model has a custom `__init__` function.     __pydantic_decorators__: Metadata containing the decorators defined on the model.         This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.     __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to         __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.     __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.     __pydantic_post_init__: The name of the post-init method for the model, if defined.     __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].     __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.     __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.      __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.     __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.      __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]         is set to `\'allow\'`.     __pydantic_fields_set__: The names of fields explicitly set during instantiation.     __pydantic_private__: Values of private attributes set on the model instance.
 * @export
 * @interface CaseStats
 */
export interface CaseStats {
    /**
     * The ID of the case type.
     * @type {string}
     * @memberof CaseStats
     */
    'case_type_id': string;
    /**
     * The ID of the case set, if applicable.
     * @type {string}
     * @memberof CaseStats
     */
    'case_set_id'?: string | null;
    /**
     * The number of cases in the case set.
     * @type {number}
     * @memberof CaseStats
     */
    'n_cases'?: number;
    /**
     * The number of own cases in the case set.
     * @type {number}
     * @memberof CaseStats
     */
    'n_own_cases'?: number;
    /**
     * The date of the first case. In case the user has rights only to lower time resolution for the case date, the first day of the week, month, quarter, year, as available to the user, is used during calculation.
     * @type {string}
     * @memberof CaseStats
     */
    'first_case_date'?: string | null;
    /**
     * The date of the last case. In case the user has rights only to lower time resolution for the case date, the first day of the week, month, quarter, year, as available to the user, is used during calculation.
     * @type {string}
     * @memberof CaseStats
     */
    'last_case_date'?: string | null;
}
/**
 * 
 * @export
 * @interface CaseType
 */
export interface CaseType {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseType
     */
    'id'?: string | null;
    /**
     * The name of the case type
     * @type {string}
     * @memberof CaseType
     */
    'name': string;
    /**
     * The description of the case type
     * @type {string}
     * @memberof CaseType
     */
    'description'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof CaseType
     */
    'disease_id'?: string | null;
    /**
     * 
     * @type {Disease}
     * @memberof CaseType
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof CaseType
     */
    'etiological_agent_id'?: string | null;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof CaseType
     */
    'etiological_agent'?: EtiologicalAgent;
    /**
     * Maximum number of cases that can be created in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CaseType
     */
    'create_max_n_cases'?: number;
    /**
     * Maximum number of cases that can be read in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CaseType
     */
    'read_max_n_cases'?: number;
    /**
     * Maximum number of cases for which a tree may be calculated, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CaseType
     */
    'read_max_tree_size'?: number;
    /**
     * Maximum number of cases that can be updated in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CaseType
     */
    'update_max_n_cases'?: number;
    /**
     * Maximum number of cases that can be deleted in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CaseType
     */
    'delete_max_n_cases'?: number;
}
/**
 * 
 * @export
 * @interface CaseTypeAccessAbac
 */
export interface CaseTypeAccessAbac {
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseTypeAccessAbac
     */
    'case_type_id': string;
    /**
     * The ID of the data collection
     * @type {string}
     * @memberof CaseTypeAccessAbac
     */
    'data_collection_id': string;
    /**
     * Whether the data collection is private, limited to the case types in the case type set. When true, add/remove case and add/remove case set are considered (i) as the right to create/delete a case or case set in this data collection (setting case.created_in_data_collection to this data collection) and (ii) as the right to share the case or case set further in other data collections. Deleting a case or case set is only allowed when it can or has been removed from all other data collections as well.
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'is_private': boolean;
    /**
     * Whether cases may be added, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'remove_case_set': boolean;
    /**
     * The IDs of the case type columns for which values can be read, limited to the case type and data collection
     * @type {Array<string>}
     * @memberof CaseTypeAccessAbac
     */
    'read_case_type_col_ids': Array<string>;
    /**
     * The IDs of the case type columns for which values can be updated, limited to the case types in the case type set
     * @type {Array<string>}
     * @memberof CaseTypeAccessAbac
     */
    'write_case_type_col_ids': Array<string>;
    /**
     * Whether case set be read, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case type and data collection
     * @type {boolean}
     * @memberof CaseTypeAccessAbac
     */
    'write_case_set': boolean;
}
/**
 * 
 * @export
 * @interface CaseTypeCol
 */
export interface CaseTypeCol {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseTypeCol
     */
    'case_type'?: CaseType;
    /**
     * The ID of the case type dimension. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'case_type_dim_id': string;
    /**
     * 
     * @type {CaseTypeDim}
     * @memberof CaseTypeCol
     */
    'case_type_dim'?: CaseTypeDim;
    /**
     * The ID of the column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'col_id': string;
    /**
     * 
     * @type {Col}
     * @memberof CaseTypeCol
     */
    'col'?: Col;
    /**
     * The code for the case type column, equal to the column code and, if present, dot \'x\' occurrence. E.g. \'Host.Vaccination.Date.COVID19.x1\' for occurrence=1, \'Specimen.Sampling.Date\' for occurrence=0
     * @type {string}
     * @memberof CaseTypeCol
     */
    'code': string;
    /**
     * The rank of the column within the case type dim for (partial) ordering, if different from the general dimension and column rank.
     * @type {number}
     * @memberof CaseTypeCol
     */
    'rank': number;
    /**
     * The label of the column for this case type, if different from the general column label.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'label'?: string | null;
    /**
     * Description of the case type column.
     * @type {string}
     * @memberof CaseTypeCol
     */
    'description'?: string | null;
    /**
     * The minimum value for a numeric column
     * @type {number}
     * @memberof CaseTypeCol
     */
    'min_value'?: number | null;
    /**
     * The maximum value for a numeric column
     * @type {number}
     * @memberof CaseTypeCol
     */
    'max_value'?: number | null;
    /**
     * The minimum datetime for a time column
     * @type {string}
     * @memberof CaseTypeCol
     */
    'min_datetime'?: string | null;
    /**
     * The maximum datetime for a time column
     * @type {string}
     * @memberof CaseTypeCol
     */
    'max_datetime'?: string | null;
    /**
     * The minimum length for a text column, if not empty
     * @type {number}
     * @memberof CaseTypeCol
     */
    'min_length'?: number | null;
    /**
     * The maximum length for a text column, if not empty
     * @type {number}
     * @memberof CaseTypeCol
     */
    'max_length'?: number | null;
    /**
     * The regular expression for a text column, if not empty
     * @type {string}
     * @memberof CaseTypeCol
     */
    'pattern'?: string | null;
    /**
     * The NCBI taxid for the column, if the column is a genetic sequence
     * @type {string}
     * @memberof CaseTypeCol
     */
    'ncbi_taxid'?: string | null;
    /**
     * The ID of the genetic sequence case type column, if this is a genetic sequence column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeCol
     */
    'genetic_sequence_case_type_col_id'?: string | null;
    /**
     * The set of tree algorithms that can be used for the case type column
     * @type {Array<TreeAlgorithmType>}
     * @memberof CaseTypeCol
     */
    'tree_algorithm_codes'?: Array<TreeAlgorithmType> | null;
    /**
     * Additional properties of the case type column.
     * @type {{ [key: string]: any; }}
     * @memberof CaseTypeCol
     */
    'props'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface CaseTypeColSet
 */
export interface CaseTypeColSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'id'?: string | null;
    /**
     * The name of a case type column set, UNIQUE
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'name': string;
    /**
     * The description of the case type column set
     * @type {string}
     * @memberof CaseTypeColSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CaseTypeColSetMember
 */
export interface CaseTypeColSetMember {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case type column set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_set_id': string;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col_id': string;
    /**
     * 
     * @type {CaseTypeCol}
     * @memberof CaseTypeColSetMember
     */
    'case_type_col'?: CaseTypeCol;
}
/**
 * 
 * @export
 * @interface CaseTypeDim
 */
export interface CaseTypeDim {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeDim
     */
    'id'?: string | null;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeDim
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseTypeDim
     */
    'case_type'?: CaseType;
    /**
     * The ID of the dimension. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeDim
     */
    'dim_id': string;
    /**
     * 
     * @type {Dim}
     * @memberof CaseTypeDim
     */
    'dim'?: Dim;
    /**
     * The index of the occurrence of the dimension for this case type. E.g. for first and second vaccination time it would be 1 and 2. Zero if only a single occurrence is expected or created.
     * @type {number}
     * @memberof CaseTypeDim
     */
    'occurrence'?: number;
    /**
     * The code for the case type dimension, equal to the dimension code and, if present, dot \'x\' occurrence. E.g. \'Host.Vaccination.Date.COVID19.x1\' for occurrence=1, \'Specimen.Sampling.Date\' for occurrence=0
     * @type {string}
     * @memberof CaseTypeDim
     */
    'code': string;
    /**
     * The label of the dimension for this case type, if different from the general dimension label.
     * @type {string}
     * @memberof CaseTypeDim
     */
    'label'?: string | null;
    /**
     * Description of the case type dimension.
     * @type {string}
     * @memberof CaseTypeDim
     */
    'description'?: string | null;
    /**
     * The rank of the case type dimension within the case type for (partial) ordering.
     * @type {number}
     * @memberof CaseTypeDim
     */
    'rank': number;
    /**
     * Indicates if this dimension is to be used to derive the case date.
     * @type {boolean}
     * @memberof CaseTypeDim
     */
    'is_case_date_dim'?: boolean;
}
/**
 * 
 * @export
 * @interface CaseTypeSet
 */
export interface CaseTypeSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeSet
     */
    'id'?: string | null;
    /**
     * The name of the case type set
     * @type {string}
     * @memberof CaseTypeSet
     */
    'name': string;
    /**
     * The description of the case type set
     * @type {string}
     * @memberof CaseTypeSet
     */
    'description'?: string | null;
    /**
     * The id of the category of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSet
     */
    'case_type_set_category_id': string;
    /**
     * 
     * @type {CaseTypeSetCategory}
     * @memberof CaseTypeSet
     */
    'case_type_set_category'?: CaseTypeSetCategory;
    /**
     * The rank of the case type set, establishing a partial order
     * @type {number}
     * @memberof CaseTypeSet
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface CaseTypeSetCategory
 */
export interface CaseTypeSetCategory {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'id'?: string | null;
    /**
     * The name of the case type set category
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'name': string;
    /**
     * The description of the case type set category
     * @type {string}
     * @memberof CaseTypeSetCategory
     */
    'description'?: string | null;
    /**
     * The rank of the case type set category
     * @type {number}
     * @memberof CaseTypeSetCategory
     */
    'rank': number;
    /**
     * 
     * @type {CaseTypeSetCategoryPurpose}
     * @memberof CaseTypeSetCategory
     */
    'purpose'?: CaseTypeSetCategoryPurpose;
}


/**
 * 
 * @export
 * @ {string}
 */

export const CaseTypeSetCategoryPurpose = {
    CONTENT: 'CONTENT',
    SECURITY: 'SECURITY'
} as const;

export type CaseTypeSetCategoryPurpose = typeof CaseTypeSetCategoryPurpose[keyof typeof CaseTypeSetCategoryPurpose];


/**
 * 
 * @export
 * @interface CaseTypeSetMember
 */
export interface CaseTypeSetMember {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof CaseTypeSetMember
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * The ID of the case type. FOREIGN KEY
     * @type {string}
     * @memberof CaseTypeSetMember
     */
    'case_type_id': string;
    /**
     * 
     * @type {CaseType}
     * @memberof CaseTypeSetMember
     */
    'case_type'?: CaseType;
}
/**
 * 
 * @export
 * @interface CaseTypeShareAbac
 */
export interface CaseTypeShareAbac {
    /**
     * The ID of the case type
     * @type {string}
     * @memberof CaseTypeShareAbac
     */
    'case_type_id': string;
    /**
     * The ID of the data collection
     * @type {string}
     * @memberof CaseTypeShareAbac
     */
    'data_collection_id': string;
    /**
     * The IDs of the data collections from which cases may be added to this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'add_case_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which cases may be removed from this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'remove_case_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which case sets may be added to this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'add_case_set_from_data_collection_ids': Array<string>;
    /**
     * The IDs of the data collections from which case sets may be removed from this data collection, limited to the case type
     * @type {Array<string>}
     * @memberof CaseTypeShareAbac
     */
    'remove_case_set_from_data_collection_ids': Array<string>;
}
/**
 * The result of uploading a single case. The case content validation results as well as the resulting cases are included as well.    PARENT CLASS DOCUMENTATION   ParentUploadResult: Represents the upload result for a Parent model upload. This class must be subclassed analogous to the ParentForUpload model it corresponds to.    PARENT CLASS DOCUMENTATION   UploadResult:  Represents the result of an upload operation, including upload status and logs.  Additional validation: - If the status is successful (NOT_FAILED), there must be no error log items. - If the status is failed, there must be at least one error log item.    PARENT CLASS DOCUMENTATION   UploadResult:  Represents the result of an upload operation, including upload status and logs.  Additional validation: - If the status is successful (NOT_FAILED), there must be no error log items. - If the status is failed, there must be at least one error log item.
 * @export
 * @interface CaseUploadResult
 */
export interface CaseUploadResult {
    /**
     * The unique identifier for the specific object instance that this result pertains to, if applicable. E.g. the object that was created or updated as part of the upload.
     * @type {string}
     * @memberof CaseUploadResult
     */
    'id'?: string | null;
    /**
     * 
     * @type {UploadStatus}
     * @memberof CaseUploadResult
     */
    'status'?: UploadStatus;
    /**
     * A list of log items capturing messages and events that occurred during the upload operation.
     * @type {Array<UploadLogItem>}
     * @memberof CaseUploadResult
     */
    'logs'?: Array<UploadLogItem>;
    /**
     * The results of uploading the external identifiers associated with the case, if any were provided, in the same order as provided.
     * @type {Array<UploadResult>}
     * @memberof CaseUploadResult
     */
    'external_identifiers'?: Array<UploadResult> | null;
    /**
     * The validated content of the case after validation or upload.
     * @type {{ [key: string]: string | null; }}
     * @memberof CaseUploadResult
     */
    'validated_content'?: { [key: string]: string | null; };
    /**
     * The data issues found for the original case content.
     * @type {Array<CaseDataIssue>}
     * @memberof CaseUploadResult
     */
    'data_issues'?: Array<CaseDataIssue>;
    /**
     * The results of uploading the read sets associated with the case, if any were provided, in the same order as provided.
     * @type {Array<UploadResult>}
     * @memberof CaseUploadResult
     */
    'read_sets'?: Array<UploadResult> | null;
    /**
     * The results of uploading the sequences associated with the case, if any were provided, in the same order as provided.
     * @type {Array<UploadResult>}
     * @memberof CaseUploadResult
     */
    'seqs'?: Array<UploadResult> | null;
}


/**
 * 
 * @export
 * @interface Col
 */
export interface Col {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Col
     */
    'id'?: string | null;
    /**
     * The ID of the dimension. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'dim_id': string;
    /**
     * 
     * @type {Dim}
     * @memberof Col
     */
    'dim'?: Dim;
    /**
     * The code suffix for the column used to compose a full column code, if needed in addition to the dimension column code prefix. See code field.
     * @type {string}
     * @memberof Col
     */
    'code_suffix'?: string | null;
    /**
     * The code for the column, equal to the dimension column code prefix dot code_suffix (dot code_suffix only if the latter is not null).
     * @type {string}
     * @memberof Col
     */
    'code': string;
    /**
     * The rank of the column within the dimension, for (partial) ordering.
     * @type {number}
     * @memberof Col
     */
    'rank'?: number;
    /**
     * The label for the column, if different from the code.
     * @type {string}
     * @memberof Col
     */
    'label'?: string | null;
    /**
     * 
     * @type {ColType}
     * @memberof Col
     */
    'col_type': ColType;
    /**
     * The ID of the concept set for the column in case of type NOMINAL, ORDINAL, INTERVAL. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'concept_set_id'?: string | null;
    /**
     * 
     * @type {ConceptSet}
     * @memberof Col
     */
    'concept_set'?: ConceptSet;
    /**
     * The ID of the region set for the column in case of type GEO. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'region_set_id'?: string | null;
    /**
     * 
     * @type {RegionSet}
     * @memberof Col
     */
    'region_set'?: RegionSet;
    /**
     * The ID of the genetic distance protocol that produces the input for the tree algorithm. FOREIGN KEY
     * @type {string}
     * @memberof Col
     */
    'genetic_distance_protocol_id'?: string | null;
    /**
     * 
     * @type {GeneticDistanceProtocol}
     * @memberof Col
     */
    'genetic_distance_protocol'?: GeneticDistanceProtocol;
    /**
     * Description of the column.
     * @type {string}
     * @memberof Col
     */
    'description'?: string | null;
    /**
     * Additional properties of the column.
     * @type {{ [key: string]: any; }}
     * @memberof Col
     */
    'props'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @ {string}
 */

export const ColType = {
    TEXT: 'TEXT',
    CONTEXT_FREE_GRAMMAR_JSON: 'CONTEXT_FREE_GRAMMAR_JSON',
    CONTEXT_FREE_GRAMMAR_XML: 'CONTEXT_FREE_GRAMMAR_XML',
    REGULAR_LANGUAGE: 'REGULAR_LANGUAGE',
    NOMINAL: 'NOMINAL',
    ORDINAL: 'ORDINAL',
    INTERVAL: 'INTERVAL',
    TIME_DAY: 'TIME_DAY',
    TIME_WEEK: 'TIME_WEEK',
    TIME_MONTH: 'TIME_MONTH',
    TIME_QUARTER: 'TIME_QUARTER',
    TIME_YEAR: 'TIME_YEAR',
    GEO_LATLON: 'GEO_LATLON',
    GEO_REGION: 'GEO_REGION',
    ID_PERSON: 'ID_PERSON',
    ID_CASE: 'ID_CASE',
    ID_SAMPLE: 'ID_SAMPLE',
    ID_EVENT: 'ID_EVENT',
    ID_GENETIC_SEQUENCE: 'ID_GENETIC_SEQUENCE',
    DECIMAL_0: 'DECIMAL_0',
    DECIMAL_1: 'DECIMAL_1',
    DECIMAL_2: 'DECIMAL_2',
    DECIMAL_3: 'DECIMAL_3',
    DECIMAL_4: 'DECIMAL_4',
    DECIMAL_5: 'DECIMAL_5',
    DECIMAL_6: 'DECIMAL_6',
    GENETIC_READS: 'GENETIC_READS',
    GENETIC_SEQUENCE: 'GENETIC_SEQUENCE',
    GENETIC_PROFILE: 'GENETIC_PROFILE',
    GENETIC_DISTANCE: 'GENETIC_DISTANCE',
    ORGANIZATION: 'ORGANIZATION',
    OTHER: 'OTHER'
} as const;

export type ColType = typeof ColType[keyof typeof ColType];


/**
 * The additional validation rules that a Col instance must comply with.
 * @export
 * @interface ColValidationRulesResponseBody
 */
export interface ColValidationRulesResponseBody {
    /**
     * The Col.col_type values that are allowed depending on the Col.dim.dim_type.
     * @type {{ [key: string]: Array<ColType>; }}
     * @memberof ColValidationRulesResponseBody
     */
    'valid_col_types_by_dim_type'?: { [key: string]: Array<ColType>; };
}
/**
 * 
 * @export
 * @ {string}
 */

export const CommandName = {
    RetrieveCasesByQueryCommand: 'RetrieveCasesByQueryCommand',
    TreeAlgorithmClassCrudCommand: 'TreeAlgorithmClassCrudCommand',
    CaseTypeSetCaseTypeUpdateAssociationCommand: 'CaseTypeSetCaseTypeUpdateAssociationCommand',
    CaseTypeCrudCommand: 'CaseTypeCrudCommand',
    GetIdentityProvidersCommand: 'GetIdentityProvidersCommand',
    CaseSetDataCollectionLinkCrudCommand: 'CaseSetDataCollectionLinkCrudCommand',
    RetrieveSubRolesCommand: 'RetrieveSubRolesCommand',
    CaseCrudCommand: 'CaseCrudCommand',
    UploadCasesCommand: 'UploadCasesCommand',
    ConceptCrudCommand: 'ConceptCrudCommand',
    RetrieveCaseRightsCommand: 'RetrieveCaseRightsCommand',
    DiseaseCrudCommand: 'DiseaseCrudCommand',
    ContactCrudCommand: 'ContactCrudCommand',
    OrganizationIdentifierIssuerLinkUpdateAssociationCommand: 'OrganizationIdentifierIssuerLinkUpdateAssociationCommand',
    UserInvitationCrudCommand: 'UserInvitationCrudCommand',
    RegionCrudCommand: 'RegionCrudCommand',
    CaseTypeDimCrudCommand: 'CaseTypeDimCrudCommand',
    RetrieveSequencingProtocolsCommand: 'RetrieveSequencingProtocolsCommand',
    CaseSetCategoryCrudCommand: 'CaseSetCategoryCrudCommand',
    CaseTypeSetMemberCrudCommand: 'CaseTypeSetMemberCrudCommand',
    RetrievePhylogeneticTreeByCasesCommand: 'RetrievePhylogeneticTreeByCasesCommand',
    RetrieveOrganizationContactCommand: 'RetrieveOrganizationContactCommand',
    DimCrudCommand: 'DimCrudCommand',
    CaseSetStatusCrudCommand: 'CaseSetStatusCrudCommand',
    UserCrudCommand: 'UserCrudCommand',
    RetrieveInviteUserConstraintsCommand: 'RetrieveInviteUserConstraintsCommand',
    OrganizationCrudCommand: 'OrganizationCrudCommand',
    DataCollectionCrudCommand: 'DataCollectionCrudCommand',
    CaseTypeColSetCrudCommand: 'CaseTypeColSetCrudCommand',
    RetrieveGeneticSequenceByCaseCommand: 'RetrieveGeneticSequenceByCaseCommand',
    OrganizationIdentifierIssuerLinkCrudCommand: 'OrganizationIdentifierIssuerLinkCrudCommand',
    CaseTypeSetCrudCommand: 'CaseTypeSetCrudCommand',
    RetrieveGeneticSequenceFastaByCaseCommand: 'RetrieveGeneticSequenceFastaByCaseCommand',
    CreateFileForReadSetCommand: 'CreateFileForReadSetCommand',
    CaseTypeColCrudCommand: 'CaseTypeColCrudCommand',
    SubjectCrudCommand: 'SubjectCrudCommand',
    EtiologicalAgentCrudCommand: 'EtiologicalAgentCrudCommand',
    EtiologyCrudCommand: 'EtiologyCrudCommand',
    TreeAlgorithmCrudCommand: 'TreeAlgorithmCrudCommand',
    CreateCaseSetCommand: 'CreateCaseSetCommand',
    RegisterInvitedUserCommand: 'RegisterInvitedUserCommand',
    DataCollectionSetDataCollectionUpdateAssociationCommand: 'DataCollectionSetDataCollectionUpdateAssociationCommand',
    RetrieveCaseStatsCommand: 'RetrieveCaseStatsCommand',
    RegionSetShapeCrudCommand: 'RegionSetShapeCrudCommand',
    ConceptSetCrudCommand: 'ConceptSetCrudCommand',
    RetrieveGeneticSequenceFastaByIdCommand: 'RetrieveGeneticSequenceFastaByIdCommand',
    ConceptRelationCrudCommand: 'ConceptRelationCrudCommand',
    RetrieveCompleteCaseTypeCommand: 'RetrieveCompleteCaseTypeCommand',
    RetrieveContainingRegionCommand: 'RetrieveContainingRegionCommand',
    IdentifierIssuerCrudCommand: 'IdentifierIssuerCrudCommand',
    OrganizationSetMemberCrudCommand: 'OrganizationSetMemberCrudCommand',
    CaseDataCollectionLinkCrudCommand: 'CaseDataCollectionLinkCrudCommand',
    UserShareCasePolicyCrudCommand: 'UserShareCasePolicyCrudCommand',
    RetrieveOrganizationsUnderAdminCommand: 'RetrieveOrganizationsUnderAdminCommand',
    RetrieveOwnPermissionsCommand: 'RetrieveOwnPermissionsCommand',
    CaseSetMemberCrudCommand: 'CaseSetMemberCrudCommand',
    SubjectIdentifierCrudCommand: 'SubjectIdentifierCrudCommand',
    CaseTypeSetCategoryCrudCommand: 'CaseTypeSetCategoryCrudCommand',
    RetrieveOrganizationAdminNameEmailsCommand: 'RetrieveOrganizationAdminNameEmailsCommand',
    UpdateUserOwnOrganizationCommand: 'UpdateUserOwnOrganizationCommand',
    OutageCrudCommand: 'OutageCrudCommand',
    RetrievePhylogeneticTreeBySequencesCommand: 'RetrievePhylogeneticTreeBySequencesCommand',
    RetrieveOutagesCommand: 'RetrieveOutagesCommand',
    GeneticDistanceProtocolCrudCommand: 'GeneticDistanceProtocolCrudCommand',
    DataCollectionSetMemberCrudCommand: 'DataCollectionSetMemberCrudCommand',
    DataCollectionSetCrudCommand: 'DataCollectionSetCrudCommand',
    RetrieveCasesByIdCommand: 'RetrieveCasesByIdCommand',
    ColCrudCommand: 'ColCrudCommand',
    OrganizationShareCasePolicyCrudCommand: 'OrganizationShareCasePolicyCrudCommand',
    OrganizationAdminPolicyCrudCommand: 'OrganizationAdminPolicyCrudCommand',
    RetrieveCaseSetRightsCommand: 'RetrieveCaseSetRightsCommand',
    RegionRelationCrudCommand: 'RegionRelationCrudCommand',
    SiteCrudCommand: 'SiteCrudCommand',
    RegionSetCrudCommand: 'RegionSetCrudCommand',
    UpdateUserCommand: 'UpdateUserCommand',
    UserAccessCasePolicyCrudCommand: 'UserAccessCasePolicyCrudCommand',
    CreateFileForSeqCommand: 'CreateFileForSeqCommand',
    RetrieveAssemblyProtocolsCommand: 'RetrieveAssemblyProtocolsCommand',
    OrganizationSetCrudCommand: 'OrganizationSetCrudCommand',
    RetrieveLicensesCommand: 'RetrieveLicensesCommand',
    OrganizationAccessCasePolicyCrudCommand: 'OrganizationAccessCasePolicyCrudCommand',
    DiseaseEtiologicalAgentUpdateAssociationCommand: 'DiseaseEtiologicalAgentUpdateAssociationCommand',
    CaseTypeColSetCaseTypeColUpdateAssociationCommand: 'CaseTypeColSetCaseTypeColUpdateAssociationCommand',
    InviteUserCommand: 'InviteUserCommand',
    RetrieveGeneticSequenceByIdCommand: 'RetrieveGeneticSequenceByIdCommand',
    CaseTypeColSetMemberCrudCommand: 'CaseTypeColSetMemberCrudCommand',
    CaseSetCrudCommand: 'CaseSetCrudCommand',
    OrganizationSetOrganizationUpdateAssociationCommand: 'OrganizationSetOrganizationUpdateAssociationCommand',
    ExternalIdentifierCrudCommand: 'ExternalIdentifierCrudCommand'
} as const;

export type CommandName = typeof CommandName[keyof typeof CommandName];


/**
 * 
 * @export
 * @ {string}
 */

export const ComparisonOperator = {
    Less_Than: '<',
    Less_Than_Or_Equal_To: '<=',
    Equal: '=',
    Greater_Than_Or_Equal_To: '>=',
    Greater_Than: '>',
    Not_Equal: '!='
} as const;

export type ComparisonOperator = typeof ComparisonOperator[keyof typeof ComparisonOperator];


/**
 * A complete case type with all its related entities, to avoid multiple queries and allow efficient access. The complete case type is unique for each (id, user_id) whereby id is the inherited case type id.
 * @export
 * @interface CompleteCaseType
 */
export interface CompleteCaseType {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof CompleteCaseType
     */
    'id'?: string | null;
    /**
     * The name of the case type
     * @type {string}
     * @memberof CompleteCaseType
     */
    'name': string;
    /**
     * The description of the case type
     * @type {string}
     * @memberof CompleteCaseType
     */
    'description'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof CompleteCaseType
     */
    'disease_id'?: string | null;
    /**
     * 
     * @type {Disease}
     * @memberof CompleteCaseType
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof CompleteCaseType
     */
    'etiological_agent_id'?: string | null;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof CompleteCaseType
     */
    'etiological_agent'?: EtiologicalAgent;
    /**
     * Maximum number of cases that can be created in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CompleteCaseType
     */
    'create_max_n_cases'?: number;
    /**
     * Maximum number of cases that can be read in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CompleteCaseType
     */
    'read_max_n_cases'?: number;
    /**
     * Maximum number of cases for which a tree may be calculated, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CompleteCaseType
     */
    'read_max_tree_size'?: number;
    /**
     * Maximum number of cases that can be updated in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CompleteCaseType
     */
    'update_max_n_cases'?: number;
    /**
     * Maximum number of cases that can be deleted in one batch, if the user\'s rights are constrained by this setting. If 0, no restriction is applied.
     * @type {number}
     * @memberof CompleteCaseType
     */
    'delete_max_n_cases'?: number;
    /**
     * The ID of the user for whom the complete case type is retrieved.
     * @type {string}
     * @memberof CompleteCaseType
     */
    'user_id': string | null;
    /**
     * The etiologies used by the case type
     * @type {{ [key: string]: Etiology; }}
     * @memberof CompleteCaseType
     */
    'etiologies': { [key: string]: Etiology; };
    /**
     * The etiological agents used by the case type
     * @type {{ [key: string]: EtiologicalAgent; }}
     * @memberof CompleteCaseType
     */
    'etiological_agents': { [key: string]: EtiologicalAgent; };
    /**
     * The dimensions used by the case type
     * @type {{ [key: string]: Dim; }}
     * @memberof CompleteCaseType
     */
    'dims': { [key: string]: Dim; };
    /**
     * The columns used by the case type
     * @type {{ [key: string]: Col; }}
     * @memberof CompleteCaseType
     */
    'cols': { [key: string]: Col; };
    /**
     * The case type dimensions
     * @type {{ [key: string]: CaseTypeDim; }}
     * @memberof CompleteCaseType
     */
    'case_type_dims': { [key: string]: CaseTypeDim; };
    /**
     * The case type columns for the case type
     * @type {{ [key: string]: CaseTypeCol; }}
     * @memberof CompleteCaseType
     */
    'case_type_cols': { [key: string]: CaseTypeCol; };
    /**
     * The case type dimensions ordered by their (occurrence, rank, code). Calculated during model validation.
     * @type {Array<string>}
     * @memberof CompleteCaseType
     */
    'ordered_case_type_dim_ids'?: Array<string>;
    /**
     * The case type columns ordered by their (ordered_case_type_dim, rank, code). Calculated during model validation.
     * @type {Array<string>}
     * @memberof CompleteCaseType
     */
    'ordered_case_type_col_ids'?: Array<string>;
    /**
     * The case type columns per case type dimension, ordered by (rank, code). Calculated during model validation.
     * @type {{ [key: string]: Array<string>; }}
     * @memberof CompleteCaseType
     */
    'ordered_case_type_col_ids_by_dim'?: { [key: string]: Array<string>; };
    /**
     * The genetic distance protocols used by the case type
     * @type {{ [key: string]: GeneticDistanceProtocol; }}
     * @memberof CompleteCaseType
     */
    'genetic_distance_protocols': { [key: string]: GeneticDistanceProtocol; };
    /**
     * The tree algorithms used by the case type
     * @type {{ [key: string]: TreeAlgorithm; }}
     * @memberof CompleteCaseType
     */
    'tree_algorithms': { [key: string]: TreeAlgorithm; };
    /**
     * The case type access ABAC object by data collection ID
     * @type {{ [key: string]: CaseTypeAccessAbac; }}
     * @memberof CompleteCaseType
     */
    'case_type_access_abacs': { [key: string]: CaseTypeAccessAbac; };
    /**
     * The case type share ABAC object by data collection ID
     * @type {{ [key: string]: CaseTypeShareAbac; }}
     * @memberof CompleteCaseType
     */
    'case_type_share_abacs': { [key: string]: CaseTypeShareAbac; };
    /**
     * The case type dimension ID to use for time-based statistics unless otherwise specified
     * @type {string}
     * @memberof CompleteCaseType
     */
    'case_date_case_type_dim_id': string | null;
    /**
     * The mapping of column types, restricted to time-related column types, to column IDs for the case date column of the case type. Calculated during model validation.
     * @type {{ [key: string]: string; }}
     * @memberof CompleteCaseType
     */
    'case_date_col_type_map'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Concept
 */
export interface Concept {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Concept
     */
    'id'?: string | null;
    /**
     * The ID of the concept set. FOREIGN KEY
     * @type {string}
     * @memberof Concept
     */
    'concept_set_id': string;
    /**
     * 
     * @type {ConceptSet}
     * @memberof Concept
     */
    'concept_set'?: ConceptSet;
    /**
     * Concept code within the set
     * @type {string}
     * @memberof Concept
     */
    'code': string;
    /**
     * The name of the concept.
     * @type {string}
     * @memberof Concept
     */
    'name'?: string | null;
    /**
     * The description of the concept.
     * @type {string}
     * @memberof Concept
     */
    'description'?: string | null;
    /**
     * The rank of the concept within the set. Must be provided for ordinal sets, for other sets it is optional and can be used for sorting.
     * @type {number}
     * @memberof Concept
     */
    'rank'?: number | null;
    /**
     * Additional properties of the concept.
     * @type {{ [key: string]: any; }}
     * @memberof Concept
     */
    'props'?: { [key: string]: any; };
}
/**
 * A relation between two concepts (analogous to RegionRelation).
 * @export
 * @interface ConceptRelation
 */
export interface ConceptRelation {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof ConceptRelation
     */
    'id'?: string | null;
    /**
     * The ID of the first concept. FOREIGN KEY
     * @type {string}
     * @memberof ConceptRelation
     */
    'from_concept_id': string;
    /**
     * 
     * @type {Concept}
     * @memberof ConceptRelation
     */
    'from_concept'?: Concept;
    /**
     * The ID of the second concept. FOREIGN KEY
     * @type {string}
     * @memberof ConceptRelation
     */
    'to_concept_id': string;
    /**
     * 
     * @type {Concept}
     * @memberof ConceptRelation
     */
    'to_concept'?: Concept;
    /**
     * 
     * @type {ConceptRelationType}
     * @memberof ConceptRelation
     */
    'relation': ConceptRelationType;
}


/**
 * 
 * @export
 * @ {string}
 */

export const ConceptRelationType = {
    CONTAINS: 'CONTAINS'
} as const;

export type ConceptRelationType = typeof ConceptRelationType[keyof typeof ConceptRelationType];


/**
 * A set of concepts in the ontology.
 * @export
 * @interface ConceptSet
 */
export interface ConceptSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof ConceptSet
     */
    'id'?: string | null;
    /**
     * The code of the concept set
     * @type {string}
     * @memberof ConceptSet
     */
    'code': string;
    /**
     * The name of the concept set
     * @type {string}
     * @memberof ConceptSet
     */
    'name': string;
    /**
     * 
     * @type {ConceptSetType}
     * @memberof ConceptSet
     */
    'type': ConceptSetType;
    /**
     * The regular expression describing the concept set, in case of type REGULAR_EXPRESSION
     * @type {string}
     * @memberof ConceptSet
     */
    'regex'?: string | null;
    /**
     * The definition of the schema describing the concept set, in case of type CONTEXT_FREE_GRAMMAR_XXX
     * @type {string}
     * @memberof ConceptSet
     */
    'schema_definition'?: string | null;
    /**
     * The URI to the schema describing the concept set, in case of type CONTEXT_FREE_GRAMMAR_XXX
     * @type {string}
     * @memberof ConceptSet
     */
    'schema_uri'?: string | null;
    /**
     * The description of the concept set.
     * @type {string}
     * @memberof ConceptSet
     */
    'description'?: string | null;
}


/**
 * 
 * @export
 * @ {string}
 */

export const ConceptSetType = {
    CONTEXT_FREE_GRAMMAR_JSON: 'CONTEXT_FREE_GRAMMAR_JSON',
    CONTEXT_FREE_GRAMMAR_XML: 'CONTEXT_FREE_GRAMMAR_XML',
    REGULAR_LANGUAGE: 'REGULAR_LANGUAGE',
    NOMINAL: 'NOMINAL',
    ORDINAL: 'ORDINAL',
    INTERVAL: 'INTERVAL'
} as const;

export type ConceptSetType = typeof ConceptSetType[keyof typeof ConceptSetType];


/**
 * A class representing contact information for an organization.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Contact
     */
    'id'?: string | null;
    /**
     * The ID of the site in case the contact is site-specific. FOREIGN KEY
     * @type {string}
     * @memberof Contact
     */
    'site_id': string;
    /**
     * 
     * @type {Site}
     * @memberof Contact
     */
    'site'?: Site;
    /**
     * The name of the contact, UNIQUE
     * @type {string}
     * @memberof Contact
     */
    'name': string;
    /**
     * The email address of the contact
     * @type {string}
     * @memberof Contact
     */
    'email'?: string | null;
    /**
     * The phone number of the contact
     * @type {string}
     * @memberof Contact
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateCaseSetRequestBody
 */
export interface CreateCaseSetRequestBody {
    /**
     * 
     * @type {CaseSet}
     * @memberof CreateCaseSetRequestBody
     */
    'case_set': CaseSet;
    /**
     * The data collections in which the case set will be put initially
     * @type {Array<string>}
     * @memberof CreateCaseSetRequestBody
     */
    'data_collection_ids'?: Array<string>;
    /**
     * The cases to be added to the case set, if any.
     * @type {Array<string>}
     * @memberof CreateCaseSetRequestBody
     */
    'case_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface CreateFileForReadSetRequestBody
 */
export interface CreateFileForReadSetRequestBody {
    /**
     * The content of the file to create as base64 encoded bytes.
     * @type {string}
     * @memberof CreateFileForReadSetRequestBody
     */
    'file_content': string;
    /**
     * Whether the file is for the forward reads (True) or reverse reads (False).
     * @type {boolean}
     * @memberof CreateFileForReadSetRequestBody
     */
    'is_fwd': boolean;
    /**
     * 
     * @type {ReadsFileFormat}
     * @memberof CreateFileForReadSetRequestBody
     */
    'file_format'?: ReadsFileFormat;
    /**
     * 
     * @type {FileCompression}
     * @memberof CreateFileForReadSetRequestBody
     */
    'file_compression'?: FileCompression;
}


/**
 * 
 * @export
 * @interface CreateFileForSeqRequestBody
 */
export interface CreateFileForSeqRequestBody {
    /**
     * The content of the file to create as base64 encoded bytes.
     * @type {string}
     * @memberof CreateFileForSeqRequestBody
     */
    'file_content': string;
    /**
     * 
     * @type {SeqFileFormat}
     * @memberof CreateFileForSeqRequestBody
     */
    'file_format'?: SeqFileFormat;
    /**
     * 
     * @type {FileCompression}
     * @memberof CreateFileForSeqRequestBody
     */
    'file_compression'?: FileCompression;
}


/**
 * Represents a collection of data.
 * @export
 * @interface DataCollection
 */
export interface DataCollection {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof DataCollection
     */
    'id'?: string | null;
    /**
     * The name of a data collection, UNIQUE
     * @type {string}
     * @memberof DataCollection
     */
    'name': string;
    /**
     * The description of the data collection.
     * @type {string}
     * @memberof DataCollection
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DataCollectionSet
 */
export interface DataCollectionSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof DataCollectionSet
     */
    'id'?: string | null;
    /**
     * The name of the data collection set
     * @type {string}
     * @memberof DataCollectionSet
     */
    'name': string;
    /**
     * The description of the data collection set.
     * @type {string}
     * @memberof DataCollectionSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DataCollectionSetMember
 */
export interface DataCollectionSetMember {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the data collection set. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'data_collection_set_id': string;
    /**
     * 
     * @type {DataCollectionSet}
     * @memberof DataCollectionSetMember
     */
    'data_collection_set'?: DataCollectionSet;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof DataCollectionSetMember
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof DataCollectionSetMember
     */
    'data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @ {string}
 */

export const DataIssueType = {
    MISSING: 'MISSING',
    INVALID: 'INVALID',
    UNAUTHORIZED: 'UNAUTHORIZED',
    CONFLICT: 'CONFLICT',
    DERIVED: 'DERIVED',
    TRANSFORMED: 'TRANSFORMED'
} as const;

export type DataIssueType = typeof DataIssueType[keyof typeof DataIssueType];


/**
 * @type Detail
 * @export
 */
export type Detail = string | { [key: string]: any; };

/**
 * 
 * @export
 * @interface Dim
 */
export interface Dim {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Dim
     */
    'id'?: string | null;
    /**
     * 
     * @type {DimType}
     * @memberof Dim
     */
    'dim_type': DimType;
    /**
     * The code for the dimension.
     * @type {string}
     * @memberof Dim
     */
    'code': string;
    /**
     * The label for the dimension.
     * @type {string}
     * @memberof Dim
     */
    'label': string;
    /**
     * The rank of the dimension, for (partial) ordering.
     * @type {number}
     * @memberof Dim
     */
    'rank'?: number;
    /**
     * The column code prefix used to compose a full column code, if different from the code field.
     * @type {string}
     * @memberof Dim
     */
    'col_code_prefix'?: string | null;
    /**
     * Description of the dimension.
     * @type {string}
     * @memberof Dim
     */
    'description'?: string | null;
    /**
     * Additional properties of the dimension.
     * @type {{ [key: string]: any; }}
     * @memberof Dim
     */
    'props'?: { [key: string]: any; };
}


/**
 * 
 * @export
 * @ {string}
 */

export const DimType = {
    TEXT: 'TEXT',
    IDENTIFIER: 'IDENTIFIER',
    NUMBER: 'NUMBER',
    TIME: 'TIME',
    GEO: 'GEO',
    ORGANIZATION: 'ORGANIZATION',
    OTHER: 'OTHER'
} as const;

export type DimType = typeof DimType[keyof typeof DimType];


/**
 * A disease.
 * @export
 * @interface Disease
 */
export interface Disease {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Disease
     */
    'id'?: string | null;
    /**
     * The name of the disease
     * @type {string}
     * @memberof Disease
     */
    'name': string;
    /**
     * The ICD code of the disease, if available
     * @type {string}
     * @memberof Disease
     */
    'icd_code'?: string | null;
}
/**
 * An etiological agent.
 * @export
 * @interface EtiologicalAgent
 */
export interface EtiologicalAgent {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'id'?: string | null;
    /**
     * The name of the etiological agent
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'name': string;
    /**
     * The type of the etiological agent
     * @type {string}
     * @memberof EtiologicalAgent
     */
    'type': string;
}
/**
 * The etiology of a disease based on an etiological agent.
 * @export
 * @interface Etiology
 */
export interface Etiology {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Etiology
     */
    'id'?: string | null;
    /**
     * The ID of the disease. FOREIGN KEY
     * @type {string}
     * @memberof Etiology
     */
    'disease_id': string;
    /**
     * 
     * @type {Disease}
     * @memberof Etiology
     */
    'disease'?: Disease;
    /**
     * The ID of the etiological agent. FOREIGN KEY
     * @type {string}
     * @memberof Etiology
     */
    'etiological_agent_id': string;
    /**
     * 
     * @type {EtiologicalAgent}
     * @memberof Etiology
     */
    'etiological_agent'?: EtiologicalAgent;
}
/**
 * An externally generated identifier of a particular type and its corresponding internal identifier. The externally generated identifier consists of the combination (identifier issuer, identifier)
 * @export
 * @interface ExternalIdentifier
 */
export interface ExternalIdentifier {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof ExternalIdentifier
     */
    'id'?: string | null;
    /**
     * 
     * @type {IdentifierType}
     * @memberof ExternalIdentifier
     */
    'identifier_type': IdentifierType;
    /**
     * The UUID of the identifier issuer that issued the external identifier
     * @type {string}
     * @memberof ExternalIdentifier
     */
    'identifier_issuer_id': string;
    /**
     * 
     * @type {IdentifierIssuer}
     * @memberof ExternalIdentifier
     */
    'identifier_issuer'?: IdentifierIssuer;
    /**
     * The external identifier
     * @type {string}
     * @memberof ExternalIdentifier
     */
    'external_id': string;
    /**
     * The internal identifier. This identifier is not guaranteed to still exist, so operations using it should check this first.
     * @type {string}
     * @memberof ExternalIdentifier
     */
    'internal_id': string;
}


/**
 * An external identifier, defined as the combination of (identifier issuer, identifier), intended for an upload operation. The identifier issuer can be given either as its code or ID to facilitate the upload operation where applicable. The model is immutable (frozen) to allow its use in sets and as dictionary keys.
 * @export
 * @interface ExternalIdentifierForUpload
 */
export interface ExternalIdentifierForUpload {
    /**
     * The UUID of the identifier issuer that issued the identifier. Must be present if the identifier_issuer_code is not present.
     * @type {string}
     * @memberof ExternalIdentifierForUpload
     */
    'identifier_issuer_id'?: string | null;
    /**
     * The code of the identifier issuer that issued the identifier. Must be present if the identifier_issuer_id is not present.
     * @type {string}
     * @memberof ExternalIdentifierForUpload
     */
    'identifier_issuer_code'?: string | null;
    /**
     * The external identifier
     * @type {string}
     * @memberof ExternalIdentifierForUpload
     */
    'external_id': string;
}
/**
 * 
 * @export
 * @ {string}
 */

export const FileCompression = {
    NONE: 'NONE',
    GZIP: 'GZIP'
} as const;

export type FileCompression = typeof FileCompression[keyof typeof FileCompression];


/**
 * @type EpiFilter
 * @export
 */
export type EpiFilter = TypedCompositeFilter | TypedDateRangeFilter | TypedDatetimeRangeFilter | TypedEqualsBooleanFilter | TypedEqualsNumberFilter | TypedEqualsStringFilter | TypedEqualsUuidFilter | TypedExistsFilter | TypedNoFilter | TypedNumberRangeFilter | TypedNumberSetFilter | TypedPartialDateRangeFilter | TypedRegexFilter | TypedStringSetFilter | TypedUuidSetFilter;

/**
 * @type FiltersInner
 * @export
 */
export type FiltersInner = TypedCompositeFilter | TypedDateRangeFilter | TypedDatetimeRangeFilter | TypedEqualsBooleanFilter | TypedEqualsNumberFilter | TypedEqualsStringFilter | TypedEqualsUuidFilter | TypedExistsFilter | TypedNoFilter | TypedNumberRangeFilter | TypedNumberSetFilter | TypedPartialDateRangeFilter | TypedRegexFilter | TypedStringSetFilter | TypedUuidSetFilter;

/**
 * 
 * @export
 * @interface GeneticDistanceProtocol
 */
export interface GeneticDistanceProtocol {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'id'?: string | null;
    /**
     * The ID of the protocol in seqdb
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'seqdb_seq_distance_protocol_id': string;
    /**
     * The name of the protocol
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'name': string;
    /**
     * The description of the protocol
     * @type {string}
     * @memberof GeneticDistanceProtocol
     */
    'description'?: string | null;
    /**
     * The maximum distance that is stored in seqdb for this protocol
     * @type {number}
     * @memberof GeneticDistanceProtocol
     */
    'seqdb_max_stored_distance'?: number | null;
    /**
     * Whether the distances between two profiles generated by this protocol are integers in seqdb
     * @type {boolean}
     * @memberof GeneticDistanceProtocol
     */
    'seqdb_is_integer_distance': boolean;
    /**
     * The minimum unit to be shown in a scale
     * @type {number}
     * @memberof GeneticDistanceProtocol
     */
    'min_scale_unit': number;
}
/**
 * A genetic sequence. Temporary implementation.
 * @export
 * @interface GeneticSequence
 */
export interface GeneticSequence {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof GeneticSequence
     */
    'id'?: string | null;
    /**
     * The nucleotide sequence
     * @type {string}
     * @memberof GeneticSequence
     */
    'nucleotide_sequence'?: string | null;
    /**
     * The distances to other sequences
     * @type {{ [key: string]: number; }}
     * @memberof GeneticSequence
     */
    'distances'?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HealthReponseBody
 */
export interface HealthReponseBody {
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthReponseBody
     */
    'status': HealthStatus;
}


/**
 * 
 * @export
 * @ {string}
 */

export const HealthStatus = {
    HEALTHY: 'HEALTHY',
    UNHEALTHY: 'UNHEALTHY'
} as const;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


/**
 * A system or process that issues identifiers. The combination (identifier_issuer, issued_identifier) is universally unique.
 * @export
 * @interface IdentifierIssuer
 */
export interface IdentifierIssuer {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'id'?: string | null;
    /**
     * The name of the issuer
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'code': string;
    /**
     * The name of the issuer
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'name': string;
    /**
     * The description of the identifier issuer.
     * @type {string}
     * @memberof IdentifierIssuer
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @ {number}
 */

export const IdentifierType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type IdentifierType = typeof IdentifierType[keyof typeof IdentifierType];


/**
 * 
 * @export
 * @interface IdentityProvider
 */
export interface IdentityProvider {
    /**
     * Name of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'name': string;
    /**
     * Label of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'label': string;
    /**
     * The issuer URL of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'issuer': string;
    /**
     * 
     * @type {AuthProtocol}
     * @memberof IdentityProvider
     */
    'auth_protocol': AuthProtocol;
    /**
     * 
     * @type {OAuthFlow}
     * @memberof IdentityProvider
     */
    'oauth_flow'?: OAuthFlow;
    /**
     * The discovery URL of the identity provider
     * @type {string}
     * @memberof IdentityProvider
     */
    'discovery_url'?: string | null;
    /**
     * The client ID that tokens should be requested for
     * @type {string}
     * @memberof IdentityProvider
     */
    'client_id'?: string | null;
    /**
     * The client secret
     * @type {string}
     * @memberof IdentityProvider
     */
    'client_secret'?: string | null;
    /**
     * The OIDC scopes, space separated
     * @type {string}
     * @memberof IdentityProvider
     */
    'scope'?: string | null;
    /**
     * Whether the identity provider is public
     * @type {boolean}
     * @memberof IdentityProvider
     */
    'public'?: boolean;
}


/**
 * @type LocationInner
 * @export
 */
export type LocationInner = number | string;

/**
 * 
 * @export
 * @interface LogItem
 */
export interface LogItem {
    /**
     * 
     * @type {LogLevel}
     * @memberof LogItem
     */
    'level': LogLevel;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'command_id': string;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof LogItem
     */
    'duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'software_version': string;
    /**
     * 
     * @type {string}
     * @memberof LogItem
     */
    'topic': string;
    /**
     * 
     * @type {Detail}
     * @memberof LogItem
     */
    'detail'?: Detail | null;
}


/**
 * 
 * @export
 * @ {string}
 */

export const LogLevel = {
    FATAL: 'FATAL',
    ERROR: 'ERROR',
    WARN: 'WARN',
    INFO: 'INFO',
    DEBUG: 'DEBUG',
    TRACE: 'TRACE'
} as const;

export type LogLevel = typeof LogLevel[keyof typeof LogLevel];


/**
 * 
 * @export
 * @interface LogRequestBody
 */
export interface LogRequestBody {
    /**
     * 
     * @type {Array<LogItem>}
     * @memberof LogRequestBody
     */
    'log_items': Array<LogItem>;
}
/**
 * 
 * @export
 * @ {string}
 */

export const LogicalOperator = {
    AND: 'AND',
    OR: 'OR',
    NOT: 'NOT',
    XOR: 'XOR',
    NAND: 'NAND',
    NOR: 'NOR',
    XNOR: 'XNOR',
    IMPLIES: 'IMPLIES',
    NIMPLIES: 'NIMPLIES'
} as const;

export type LogicalOperator = typeof LogicalOperator[keyof typeof LogicalOperator];


/**
 * @type MembersInner
 * @export
 */
export type MembersInner = number | string;

/**
 * 
 * @export
 * @ {string}
 */

export const OAuthFlow = {
    AUTHORIZATION_CODE: 'AUTHORIZATION_CODE',
    CLIENT_CREDENTIALS: 'CLIENT_CREDENTIALS',
    RESOURCE_OWNER: 'RESOURCE_OWNER',
    HYBRID: 'HYBRID',
    DEVICE_AUTHORIZATION: 'DEVICE_AUTHORIZATION',
    PKCE: 'PKCE'
} as const;

export type OAuthFlow = typeof OAuthFlow[keyof typeof OAuthFlow];


/**
 * 
 * @export
 * @ {string}
 */

export const OnExistsUploadAction = {
    ERROR: 'ERROR',
    UPDATE: 'UPDATE',
    SKIP: 'SKIP'
} as const;

export type OnExistsUploadAction = typeof OnExistsUploadAction[keyof typeof OnExistsUploadAction];


/**
 * Represents an organization.
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Organization
     */
    'id'?: string | null;
    /**
     * The name of the organization, UNIQUE
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * The legal entity code of the organization, UNIQUE
     * @type {string}
     * @memberof Organization
     */
    'legal_entity_code': string;
}
/**
 * Stores the access rights of an organization to a particular data collection. If an organization does not have a policy to a data collection, it has no access rights to that data collection.  The access rights are limited to the case types in the case type set. If a case type is not in the case type set, the organization has no access rights to that data collection for that case type.
 * @export
 * @interface OrganizationAccessCasePolicy
 */
export interface OrganizationAccessCasePolicy {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationAccessCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationAccessCasePolicy
     */
    'organization'?: Organization;
    /**
     * Whether the data collection is private, limited to the case types in the case type set. When true, add/remove case and add/remove case set are considered (i) as the right to create/delete a case or case set in this data collection (setting case.created_in_data_collection to this data collection) and (ii) as the right to share the case or case set further in other data collections. Deleting a case or case set is only allowed when it can or has been removed from all other data collections as well.
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'is_private': boolean;
    /**
     * The ID of the case type column set for which values can be read, limited to the case types in the case type set. If empty, there are no read rights. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column set for which values can be updated, limited to the case types in the case type set.  If empty, there are no write rights. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_type_col_set'?: CaseTypeColSet;
    /**
     * Whether case set be read, limited to the case types in the case type set
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case types in the case type set
     * @type {boolean}
     * @memberof OrganizationAccessCasePolicy
     */
    'write_case_set': boolean;
}
/**
 * Defines whether a user is an admin for an organization. If so, and if the user has the role ORG_ADMIN, they will be able to: 1) Invite new users of this organization. 2) Manage the case and case set access and share rights of these users.  The user will not be able to: 1) Perform the operations above for any other organization for which there    is no corresponding admin policy. 2) Set the case and case set access and share case rights for the    organization itself. This has to be done by a user with role APP_ADMIN.  Users with role APP_ADMIN or above do not require an admin policy to perform these actions. They are de facto organization admin for all organizations.
 * @export
 * @interface OrganizationAdminPolicy
 */
export interface OrganizationAdminPolicy {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'id'?: string | null;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationAdminPolicy
     */
    'organization'?: Organization;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationAdminPolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof OrganizationAdminPolicy
     */
    'user'?: User;
    /**
     * Whether the user is an admin for the organization
     * @type {boolean}
     * @memberof OrganizationAdminPolicy
     */
    'is_active': boolean;
}
/**
 * The association between an organization and an identifier issuer.  This information can be used to restrict which identifier issuers are available to users of a particular organization.
 * @export
 * @interface OrganizationIdentifierIssuerLink
 */
export interface OrganizationIdentifierIssuerLink {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationIdentifierIssuerLink
     */
    'id'?: string | null;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationIdentifierIssuerLink
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationIdentifierIssuerLink
     */
    'organization'?: Organization;
    /**
     * The ID of the identifier issuer. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationIdentifierIssuerLink
     */
    'identifier_issuer_id': string;
    /**
     * 
     * @type {IdentifierIssuer}
     * @memberof OrganizationIdentifierIssuerLink
     */
    'identifier_issuer'?: IdentifierIssuer;
}
/**
 * 
 * @export
 * @interface OrganizationSet
 */
export interface OrganizationSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationSet
     */
    'id'?: string | null;
    /**
     * The name of the organization set
     * @type {string}
     * @memberof OrganizationSet
     */
    'name': string;
    /**
     * The description of the organization set.
     * @type {string}
     * @memberof OrganizationSet
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface OrganizationSetMember
 */
export interface OrganizationSetMember {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'id'?: string | null;
    /**
     * The ID of the organization set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'organization_set_id': string;
    /**
     * 
     * @type {OrganizationSet}
     * @memberof OrganizationSetMember
     */
    'organization_set'?: OrganizationSet;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationSetMember
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationSetMember
     */
    'organization'?: Organization;
}
/**
 * Stores any additional case or case set share rights of an organization to a particular data collection, if the case or case set is already in a particular other data collection.  The share rights are limited to the case types in the case type set. If a case type is not in the case type set, the organization has no share rights to that data collection for that case type.
 * @export
 * @interface OrganizationShareCasePolicy
 */
export interface OrganizationShareCasePolicy {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationShareCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof OrganizationShareCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof OrganizationShareCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof OrganizationShareCasePolicy
     */
    'organization'?: Organization;
    /**
     * The ID of the data collection from which the case type set is shared. FOREIGN KEY
     * @type {string}
     * @memberof OrganizationShareCasePolicy
     */
    'from_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof OrganizationShareCasePolicy
     */
    'from_data_collection'?: DataCollection;
}
/**
 * Represents a system outage.
 * @export
 * @interface Outage
 */
export interface Outage {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Outage
     */
    'id'?: string | null;
    /**
     * Description of the system outage.
     * @type {string}
     * @memberof Outage
     */
    'description'?: string | null;
    /**
     * The date-time when the system outage starts.
     * @type {string}
     * @memberof Outage
     */
    'active_from'?: string | null;
    /**
     * The date-time when the system outage ends.
     * @type {string}
     * @memberof Outage
     */
    'active_to'?: string | null;
    /**
     * The date-time when the system outage is announced.
     * @type {string}
     * @memberof Outage
     */
    'visible_from'?: string | null;
    /**
     * The date-time when the system outage is no longer announced.
     * @type {string}
     * @memberof Outage
     */
    'visible_to'?: string | null;
    /**
     * Whether the system outage is currently active, this overrides active_from and active_to.
     * @type {boolean}
     * @memberof Outage
     */
    'is_active'?: boolean | null;
    /**
     * Whether the system outage is currently visible, this overrides visible_from and visible_to.
     * @type {boolean}
     * @memberof Outage
     */
    'is_visible'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PackageMetadata
 */
export interface PackageMetadata {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof PackageMetadata
     */
    'id'?: string | null;
    /**
     * Name of the package.
     * @type {string}
     * @memberof PackageMetadata
     */
    'name': string;
    /**
     * Version of the package.
     * @type {string}
     * @memberof PackageMetadata
     */
    'version': string;
    /**
     * License information for the package.
     * @type {string}
     * @memberof PackageMetadata
     */
    'license'?: string | null;
    /**
     * Homepage URL of the package.
     * @type {string}
     * @memberof PackageMetadata
     */
    'homepage'?: string | null;
}
/**
 * 
 * @export
 * @ {string}
 */

export const PermissionType = {
    CREATE: 'CREATE',
    READ: 'READ',
    UPDATE: 'UPDATE',
    DELETE: 'DELETE',
    EXECUTE: 'EXECUTE'
} as const;

export type PermissionType = typeof PermissionType[keyof typeof PermissionType];


/**
 * A phylogenetic tree, including a description of the leaves and how it was generated.
 * @export
 * @interface PhylogeneticTree
 */
export interface PhylogeneticTree {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'id'?: string | null;
    /**
     * The ID of the tree algorithm. FOREIGN KEY
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm_id'?: string | null;
    /**
     * 
     * @type {TreeAlgorithm}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm'?: TreeAlgorithm;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof PhylogeneticTree
     */
    'tree_algorithm_code': TreeAlgorithmType;
    /**
     * The ID of the genetic distance protocol. FOREIGN KEY
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'genetic_distance_protocol_id'?: string | null;
    /**
     * 
     * @type {GeneticDistanceProtocol}
     * @memberof PhylogeneticTree
     */
    'genetic_distance_protocol'?: GeneticDistanceProtocol;
    /**
     * The list of unique identifiers of the leaves of the phylogenetic tree.
     * @type {Array<string>}
     * @memberof PhylogeneticTree
     */
    'leaf_ids'?: Array<string> | null;
    /**
     * The list of unique identifiers of the sequence of each leaf of the phylogenetic tree.
     * @type {Array<string>}
     * @memberof PhylogeneticTree
     */
    'sequence_ids'?: Array<string> | null;
    /**
     * The Newick representation of the phylogenetic tree.
     * @type {string}
     * @memberof PhylogeneticTree
     */
    'newick_repr': string;
}


/**
 * A single read set to be uploaded and associated with both an existing case in casedb and a potentially existing sample in seqdb.  The sample can be identified in seqdb either by its internal ID (sample_id) or by an external identifier (external_sample_id). The ID of created read set is intended to be added to the corresponding case in casedb as the content of the given case type column.    PARENT CLASS DOCUMENTATION   IsNewIdMixin:  Mixin that adds an is_new_id field to indicate whether the model instance is new and has an externally assigned ID rather than one assigned by the system. Assumes that the inheriting model also has an \'id\' field.  Additional validation: - If is_new_id is True, the model id field field may not be None or NULL_ID.
 * @export
 * @interface ReadSetForUpload
 */
export interface ReadSetForUpload {
    /**
     * Indicates whether the model instance is both new (not yet stored) and its ID is assigned outside the system, e.g. for having the same IDs between different environments.
     * @type {boolean}
     * @memberof ReadSetForUpload
     */
    'is_new_id'?: boolean;
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'id'?: string | null;
    /**
     * The UUID of the case that the read set is associated with. If not available, the null ID is put.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'case_id'?: string;
    /**
     * The ID of the case type column with column type genetic reads that the read set is or will be associated with.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'case_type_col_id': string;
    /**
     * The UUID of the sample in seqdb that the read set is associated with. If not available, the null ID is put. Must be provided if external_sample_id is not provided.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'sample_id'?: string;
    /**
     * 
     * @type {ExternalIdentifierForUpload}
     * @memberof ReadSetForUpload
     */
    'external_sample_id'?: ExternalIdentifierForUpload;
    /**
     * The UUID of the sequencing protocol, if available. If not available, the null ID is put. Must be present if sequencing_protocol_code is not present. The use of sequencing_protocol_id is preferred over sequencing_protocol_code since the latter may change.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'sequencing_protocol_id'?: string;
    /**
     * The code of the sequencing protocol. Must be present if sequencing_protocol_id is not present. The use of sequencing_protocol_code is meant for situations where the sequencing_protocol_id is not known, but the code is and/or improves human interpretation.
     * @type {string}
     * @memberof ReadSetForUpload
     */
    'sequencing_protocol_code'?: string | null;
}
/**
 * 
 * @export
 * @ {string}
 */

export const ReadsFileFormat = {
    FASTQ: 'FASTQ'
} as const;

export type ReadsFileFormat = typeof ReadsFileFormat[keyof typeof ReadsFileFormat];


/**
 * Geographical representation of a region.
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Region
     */
    'id'?: string | null;
    /**
     * The ID of the region set. FOREIGN KEY
     * @type {string}
     * @memberof Region
     */
    'region_set_id': string;
    /**
     * 
     * @type {RegionSet}
     * @memberof Region
     */
    'region_set'?: RegionSet;
    /**
     * The code of the region.
     * @type {string}
     * @memberof Region
     */
    'code': string;
    /**
     * The name of the region.
     * @type {string}
     * @memberof Region
     */
    'name': string;
    /**
     * The latitude of the region\'s centroid.
     * @type {number}
     * @memberof Region
     */
    'centroid_lat': number;
    /**
     * The longitude of the region\'s centroid.
     * @type {number}
     * @memberof Region
     */
    'centroid_lon': number;
    /**
     * The latitude of the region\'s center.
     * @type {number}
     * @memberof Region
     */
    'center_lat': number;
    /**
     * The longitude of the region\'s center.
     * @type {number}
     * @memberof Region
     */
    'center_lon': number;
}
/**
 * Geographical relation between two regions.
 * @export
 * @interface RegionRelation
 */
export interface RegionRelation {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof RegionRelation
     */
    'id'?: string | null;
    /**
     * The ID of the source region. FOREIGN KEY
     * @type {string}
     * @memberof RegionRelation
     */
    'from_region_id': string;
    /**
     * 
     * @type {Region}
     * @memberof RegionRelation
     */
    'from_region'?: Region;
    /**
     * The ID of the target region. FOREIGN KEY
     * @type {string}
     * @memberof RegionRelation
     */
    'to_region_id': string;
    /**
     * 
     * @type {Region}
     * @memberof RegionRelation
     */
    'to_region'?: Region;
    /**
     * 
     * @type {RegionRelationType}
     * @memberof RegionRelation
     */
    'relation': RegionRelationType;
}


/**
 * 
 * @export
 * @ {string}
 */

export const RegionRelationType = {
    IS_SEPARATE_FROM: 'IS_SEPARATE_FROM',
    IS_ADJACENT_TO: 'IS_ADJACENT_TO',
    OVERLAPS_WITH: 'OVERLAPS_WITH',
    CONTAINS: 'CONTAINS'
} as const;

export type RegionRelationType = typeof RegionRelationType[keyof typeof RegionRelationType];


/**
 * Set of regions that do not overlap geographically or otherwise did not exist at the same moment in time.
 * @export
 * @interface RegionSet
 */
export interface RegionSet {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof RegionSet
     */
    'id'?: string | null;
    /**
     * The code of the region set.
     * @type {string}
     * @memberof RegionSet
     */
    'code': string;
    /**
     * The name of the region set.
     * @type {string}
     * @memberof RegionSet
     */
    'name': string;
    /**
     * Whether the region\'s code should be used as the label. E.g. in case of postal code the code could be used instead of the name of the region.
     * @type {boolean}
     * @memberof RegionSet
     */
    'region_code_as_label': boolean;
    /**
     * The geographic resolution; higher values indicate higher resolution.
     * @type {number}
     * @memberof RegionSet
     */
    'resolution': number;
}
/**
 * Geographical shape representation for a region set.
 * @export
 * @interface RegionSetShape
 */
export interface RegionSetShape {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof RegionSetShape
     */
    'id'?: string | null;
    /**
     * The ID of the region set. FOREIGN KEY
     * @type {string}
     * @memberof RegionSetShape
     */
    'region_set_id': string;
    /**
     * 
     * @type {RegionSet}
     * @memberof RegionSetShape
     */
    'region_set'?: RegionSet;
    /**
     * The scale of the shape representation.
     * @type {number}
     * @memberof RegionSetShape
     */
    'scale': number;
    /**
     * The GeoJSON representation of the region set shape.
     * @type {string}
     * @memberof RegionSetShape
     */
    'geo_json': string;
}
/**
 * 
 * @export
 * @interface RetrieveCaseRightsRequestBody
 */
export interface RetrieveCaseRightsRequestBody {
    /**
     * The case type id to retrieve case access for.
     * @type {string}
     * @memberof RetrieveCaseRightsRequestBody
     */
    'case_type_id': string;
    /**
     * The case ids to retrieve access for. UNIQUE
     * @type {Array<string>}
     * @memberof RetrieveCaseRightsRequestBody
     */
    'case_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveCaseSetStatsRequestBody
 */
export interface RetrieveCaseSetStatsRequestBody {
    /**
     * The case set ids to retrieve stats for, if not all.
     * @type {Array<string>}
     * @memberof RetrieveCaseSetStatsRequestBody
     */
    'case_set_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveCaseTypeStatsRequestBody
 */
export interface RetrieveCaseTypeStatsRequestBody {
    /**
     * The case type ids to retrieve stats for, if not all.
     * @type {Array<string>}
     * @memberof RetrieveCaseTypeStatsRequestBody
     */
    'case_type_ids'?: Array<string> | null;
    /**
     * 
     * @type {TypedDatetimeRangeFilter}
     * @memberof RetrieveCaseTypeStatsRequestBody
     */
    'datetime_range_filter'?: TypedDatetimeRangeFilter;
}
/**
 * 
 * @export
 * @interface RetrieveCasesByIdsRequestBody
 */
export interface RetrieveCasesByIdsRequestBody {
    /**
     * The case type id to retrieve cases for.
     * @type {string}
     * @memberof RetrieveCasesByIdsRequestBody
     */
    'case_type_id': string;
    /**
     * The case ids to retrieve cases for. All cases must belong to the given case type. UNIQUE
     * @type {Array<string>}
     * @memberof RetrieveCasesByIdsRequestBody
     */
    'case_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveGeneticSequenceRequestBody
 */
export interface RetrieveGeneticSequenceRequestBody {
    /**
     * The case type ID that all the cases must belong to.
     * @type {string}
     * @memberof RetrieveGeneticSequenceRequestBody
     */
    'case_type_id': string;
    /**
     * The ID of the genetic sequence case type column to use.
     * @type {string}
     * @memberof RetrieveGeneticSequenceRequestBody
     */
    'genetic_sequence_case_type_col_id': string;
    /**
     * The IDs of the cases to retrieve genetic sequences for.
     * @type {Array<string>}
     * @memberof RetrieveGeneticSequenceRequestBody
     */
    'case_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface RetrieveOrganizationContactRequestBody
 */
export interface RetrieveOrganizationContactRequestBody {
    /**
     * The organization IDs to retrieve contacts for.
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'organization_ids'?: Array<string> | null;
    /**
     * The site IDs to retrieve contacts for.
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'site_ids'?: Array<string> | null;
    /**
     * The contact IDs to retrieve contacts for.
     * @type {Array<string>}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'contact_ids'?: Array<string> | null;
    /**
     * Additional properties for the request.
     * @type {{ [key: string]: any; }}
     * @memberof RetrieveOrganizationContactRequestBody
     */
    'props'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RetrievePhylogeneticTreeRequestBody
 */
export interface RetrievePhylogeneticTreeRequestBody {
    /**
     * The case type ID that all the cases must belong to.
     * @type {string}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'case_type_id': string;
    /**
     * The ID of the genetic distance case type column to use.
     * @type {string}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'genetic_distance_case_type_col_id': string;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'tree_algorithm_code': TreeAlgorithmType;
    /**
     * The IDs of the cases to calculate the phylogenetic tree for.
     * @type {Array<string>}
     * @memberof RetrievePhylogeneticTreeRequestBody
     */
    'case_ids': Array<string>;
}


/**
 * 
 * @export
 * @ {string}
 */

export const SeqFileFormat = {
    FASTA: 'FASTA'
} as const;

export type SeqFileFormat = typeof SeqFileFormat[keyof typeof SeqFileFormat];


/**
 * A single sequence to be uploaded and associated with both an existing case in casedb and a potentially existing sample in seqdb.  The sample can be identified in seqdb either by its internal ID (sample_id) or by an external identifier (external_sample_id). The ID of created sequence is intended to be added to the corresponding case in casedb as the content of the given case type column.    PARENT CLASS DOCUMENTATION   IsNewIdMixin:  Mixin that adds an is_new_id field to indicate whether the model instance is new and has an externally assigned ID rather than one assigned by the system. Assumes that the inheriting model also has an \'id\' field.  Additional validation: - If is_new_id is True, the model id field field may not be None or NULL_ID.
 * @export
 * @interface SeqForUpload
 */
export interface SeqForUpload {
    /**
     * Indicates whether the model instance is both new (not yet stored) and its ID is assigned outside the system, e.g. for having the same IDs between different environments.
     * @type {boolean}
     * @memberof SeqForUpload
     */
    'is_new_id'?: boolean;
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof SeqForUpload
     */
    'id'?: string | null;
    /**
     * The UUID of the case that the read set is associated with. If not available, the null ID is put.
     * @type {string}
     * @memberof SeqForUpload
     */
    'case_id'?: string;
    /**
     * The ID of the case type column that the sequence is or will be associated with.
     * @type {string}
     * @memberof SeqForUpload
     */
    'case_type_col_id': string;
    /**
     * The UUID of the sample in seqdb that the sequence is associated with. If not available, the null ID is put. Must be provided if external_sample_id is not provided.
     * @type {string}
     * @memberof SeqForUpload
     */
    'sample_id'?: string;
    /**
     * 
     * @type {ExternalIdentifierForUpload}
     * @memberof SeqForUpload
     */
    'external_sample_id'?: ExternalIdentifierForUpload;
    /**
     * The UUID of the assembly protocol, if available. If not available, the null ID is put. Must be present if assembly_protocol_code is not present. The use of assembly_protocol_id is preferred over assembly_protocol_code since the latter may change.
     * @type {string}
     * @memberof SeqForUpload
     */
    'assembly_protocol_id'?: string;
    /**
     * The code of the assembly protocol. Must be present if assembly_protocol_id is not present. The use of assembly_protocol_code is meant for situations where the assembly_protocol_id is not known, but the code is and/or improves human interpretation.
     * @type {string}
     * @memberof SeqForUpload
     */
    'assembly_protocol_code'?: string | null;
}
/**
 * The protocol used for sequencing a sample.    PARENT CLASS DOCUMENTATION   ProtocolMixin:  Mixin class to add protocol related fields to a model.
 * @export
 * @interface SequencingProtocol
 */
export interface SequencingProtocol {
    /**
     * The code of the protocol
     * @type {string}
     * @memberof SequencingProtocol
     */
    'code': string;
    /**
     * The name of the protocol
     * @type {string}
     * @memberof SequencingProtocol
     */
    'name': string;
    /**
     * The version of the protocol
     * @type {string}
     * @memberof SequencingProtocol
     */
    'version'?: string | null;
    /**
     * The description of the protocol
     * @type {string}
     * @memberof SequencingProtocol
     */
    'description'?: string | null;
    /**
     * The properties of the protocol
     * @type {{ [key: string]: string; }}
     * @memberof SequencingProtocol
     */
    'props'?: { [key: string]: string; };
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof SequencingProtocol
     */
    'id'?: string | null;
}
/**
 * Represents a physical site of an organization.
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof Site
     */
    'id'?: string | null;
    /**
     * The ID of the organization. FOREIGN KEY
     * @type {string}
     * @memberof Site
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof Site
     */
    'organization'?: Organization;
    /**
     * The name of an organization, UNIQUE
     * @type {string}
     * @memberof Site
     */
    'name': string;
}
/**
 * A person context bound to a particular data collection.
 * @export
 * @interface EpiSubject
 */
export interface EpiSubject {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof EpiSubject
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof EpiSubject
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof EpiSubject
     */
    'data_collection'?: DataCollection;
    /**
     * A dictionary of external identifiers for the subject
     * @type {{ [key: string]: string; }}
     * @memberof EpiSubject
     */
    'external_identifiers'?: { [key: string]: string; } | null;
    /**
     * A dictionary containing the content of the subject
     * @type {{ [key: string]: any; }}
     * @memberof EpiSubject
     */
    'content': { [key: string]: any; };
}
/**
 * A unique identifier for a subject, generated by a particular identifier issuer.
 * @export
 * @interface SubjectIdentifier
 */
export interface SubjectIdentifier {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof SubjectIdentifier
     */
    'id'?: string | null;
    /**
     * The ID of the subject. FOREIGN KEY
     * @type {string}
     * @memberof SubjectIdentifier
     */
    'subject_id': string;
    /**
     * 
     * @type {EpiSubject}
     * @memberof SubjectIdentifier
     */
    'subject'?: EpiSubject;
    /**
     * The ID of the identifier issuer. FOREIGN KEY
     * @type {string}
     * @memberof SubjectIdentifier
     */
    'identifier_issuer_id': string;
    /**
     * 
     * @type {IdentifierIssuer}
     * @memberof SubjectIdentifier
     */
    'identifier_issuer'?: IdentifierIssuer;
    /**
     * The identifier
     * @type {string}
     * @memberof SubjectIdentifier
     */
    'identifier': string;
}
/**
 * See https://en.wikipedia.org/wiki/Hierarchical_clustering, https://en.wikipedia.org/wiki/Neighbor_joining,  https://en.wikipedia.org/wiki/Computational_phylogenetics,  https://en.wikipedia.org/wiki/Spanning_tree
 * @export
 * @interface TreeAlgorithm
 */
export interface TreeAlgorithm {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'id'?: string | null;
    /**
     * The ID of the tree algorithm class. FOREIGN KEY
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'tree_algorithm_class_id': string;
    /**
     * 
     * @type {TreeAlgorithmClass}
     * @memberof TreeAlgorithm
     */
    'tree_algorithm_class'?: TreeAlgorithmClass;
    /**
     * The ID of the tree algorithm in seqdb
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'seqdb_tree_algorithm_id': string;
    /**
     * 
     * @type {TreeAlgorithmType}
     * @memberof TreeAlgorithm
     */
    'code': TreeAlgorithmType;
    /**
     * The name of the tree algorithm
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'name': string;
    /**
     * The description of the tree algorithm
     * @type {string}
     * @memberof TreeAlgorithm
     */
    'description'?: string | null;
    /**
     * Whether the tree is ultrametric
     * @type {boolean}
     * @memberof TreeAlgorithm
     */
    'is_ultrametric': boolean;
    /**
     * The rank of the tree algorithm, if relevant.
     * @type {number}
     * @memberof TreeAlgorithm
     */
    'rank'?: number | null;
}


/**
 * 
 * @export
 * @interface TreeAlgorithmClass
 */
export interface TreeAlgorithmClass {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'id'?: string | null;
    /**
     * The code of the tree algorithm class
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'code': string;
    /**
     * The name of the tree algorithm class
     * @type {string}
     * @memberof TreeAlgorithmClass
     */
    'name': string;
    /**
     * Whether the sequence or alignment is needed as input
     * @type {boolean}
     * @memberof TreeAlgorithmClass
     */
    'is_seq_based': boolean;
    /**
     * Whether the distance between sequences is needed as input
     * @type {boolean}
     * @memberof TreeAlgorithmClass
     */
    'is_dist_based': boolean;
    /**
     * The rank of the tree algorithm class, if relevant.
     * @type {number}
     * @memberof TreeAlgorithmClass
     */
    'rank'?: number | null;
}
/**
 * 
 * @export
 * @ {string}
 */

export const TreeAlgorithmType = {
    SLINK: 'SLINK',
    CLINK: 'CLINK',
    UPGMA: 'UPGMA',
    WPGMA: 'WPGMA',
    UPGMC: 'UPGMC',
    WPGMC: 'WPGMC',
    VERSATILE: 'VERSATILE',
    MISSQ: 'MISSQ',
    MNSSQ: 'MNSSQ',
    MIVAR: 'MIVAR',
    MNVAR: 'MNVAR',
    MINI_MAX: 'MINI_MAX',
    HAUSDORFF: 'HAUSDORFF',
    MIN_SUM_MEDOID: 'MIN_SUM_MEDOID',
    MIN_SUM_INCREASE_MEDOID: 'MIN_SUM_INCREASE_MEDOID',
    MEDOID: 'MEDOID',
    MIN_ENERGY: 'MIN_ENERGY',
    FITCH_MARGOLIASH: 'FITCH_MARGOLIASH',
    MAX_PARSIMONY: 'MAX_PARSIMONY',
    ML: 'ML',
    BAYESIAN_INFERENCE: 'BAYESIAN_INFERENCE',
    MIN_SPANNING: 'MIN_SPANNING',
    NJ: 'NJ'
} as const;

export type TreeAlgorithmType = typeof TreeAlgorithmType[keyof typeof TreeAlgorithmType];


/**
 * 
 * @export
 * @interface TypedCompositeFilter
 */
export interface TypedCompositeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedCompositeFilter
     */
    'invert'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedCompositeFilter
     */
    'key'?: string | null;
    /**
     * The list of filters.
     * @type {Array<FiltersInner>}
     * @memberof TypedCompositeFilter
     */
    'filters': Array<FiltersInner>;
    /**
     * 
     * @type {LogicalOperator}
     * @memberof TypedCompositeFilter
     */
    'operator'?: LogicalOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedCompositeFilter
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface TypedDateRangeFilter
 */
export interface TypedDateRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedDateRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'lower_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDateRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'upper_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDateRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedDateRangeFilter
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface TypedDatetimeRangeFilter
 */
export interface TypedDatetimeRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedDatetimeRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'lower_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDatetimeRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'upper_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedDatetimeRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedDatetimeRangeFilter
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface TypedEqualsBooleanFilter
 */
export interface TypedEqualsBooleanFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsBooleanFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsBooleanFilter
     */
    'key'?: string;
    /**
     * The boolean value to match.
     * @type {boolean}
     * @memberof TypedEqualsBooleanFilter
     */
    'value': boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsBooleanFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedEqualsNumberFilter
 */
export interface TypedEqualsNumberFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsNumberFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsNumberFilter
     */
    'key'?: string;
    /**
     * 
     * @type {Value}
     * @memberof TypedEqualsNumberFilter
     */
    'value': Value;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsNumberFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedEqualsStringFilter
 */
export interface TypedEqualsStringFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsStringFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'key'?: string;
    /**
     * The string to match.
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsStringFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedEqualsUuidFilter
 */
export interface TypedEqualsUuidFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedEqualsUuidFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'key'?: string;
    /**
     * The UUID to match.
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof TypedEqualsUuidFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedExistsFilter
 */
export interface TypedExistsFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedExistsFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedExistsFilter
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof TypedExistsFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedNoFilter
 */
export interface TypedNoFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNoFilter
     */
    'invert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TypedNoFilter
     */
    'key'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedNoFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedNumberRangeFilter
 */
export interface TypedNumberRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNumberRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedNumberRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {number}
     * @memberof TypedNumberRangeFilter
     */
    'lower_bound'?: number | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedNumberRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {number}
     * @memberof TypedNumberRangeFilter
     */
    'upper_bound'?: number | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedNumberRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedNumberRangeFilter
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface TypedNumberSetFilter
 */
export interface TypedNumberSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedNumberSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedNumberSetFilter
     */
    'key'?: string;
    /**
     * The numbers to match.
     * @type {Array<MembersInner>}
     * @memberof TypedNumberSetFilter
     */
    'members'?: Array<MembersInner>;
    /**
     * 
     * @type {string}
     * @memberof TypedNumberSetFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedPartialDateRangeFilter
 */
export interface TypedPartialDateRangeFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedPartialDateRangeFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'key'?: string;
    /**
     * The lower bound of the range.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'lower_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedPartialDateRangeFilter
     */
    'lower_bound_censor'?: ComparisonOperator;
    /**
     * The upper bound of the range.
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'upper_bound'?: string | null;
    /**
     * 
     * @type {ComparisonOperator}
     * @memberof TypedPartialDateRangeFilter
     */
    'upper_bound_censor'?: ComparisonOperator;
    /**
     * 
     * @type {string}
     * @memberof TypedPartialDateRangeFilter
     */
    'type': string;
}


/**
 * 
 * @export
 * @interface TypedRegexFilter
 */
export interface TypedRegexFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedRegexFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'key'?: string;
    /**
     * The regular expression to match.
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'pattern': string;
    /**
     * 
     * @type {string}
     * @memberof TypedRegexFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedStringSetFilter
 */
export interface TypedStringSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedStringSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedStringSetFilter
     */
    'key'?: string;
    /**
     * The strings to match.
     * @type {Array<string>}
     * @memberof TypedStringSetFilter
     */
    'members'?: Array<string>;
    /**
     * Whether the match is case sensitive.
     * @type {boolean}
     * @memberof TypedStringSetFilter
     */
    'case_sensitive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TypedStringSetFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TypedUuidSetFilter
 */
export interface TypedUuidSetFilter {
    /**
     * Whether to invert the filter.
     * @type {boolean}
     * @memberof TypedUuidSetFilter
     */
    'invert'?: boolean;
    /**
     * The column key to apply the filter to, when applied to a row. If None, the filter cannot be applied to a row, only to a column.
     * @type {string}
     * @memberof TypedUuidSetFilter
     */
    'key'?: string;
    /**
     * The UUIDs to match.
     * @type {Array<string>}
     * @memberof TypedUuidSetFilter
     */
    'members'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TypedUuidSetFilter
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface UpdateCaseTypeColSetCaseTypeColsRequestBody
 */
export interface UpdateCaseTypeColSetCaseTypeColsRequestBody {
    /**
     * The members of the case type col set.
     * @type {Array<CaseTypeColSetMember>}
     * @memberof UpdateCaseTypeColSetCaseTypeColsRequestBody
     */
    'case_type_col_set_members': Array<CaseTypeColSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateCaseTypeSetCaseTypesRequestBody
 */
export interface UpdateCaseTypeSetCaseTypesRequestBody {
    /**
     * The members of the case type set.
     * @type {Array<CaseTypeSetMember>}
     * @memberof UpdateCaseTypeSetCaseTypesRequestBody
     */
    'case_type_set_members': Array<CaseTypeSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateDataCollectionSetDataCollectionRequestBody
 */
export interface UpdateDataCollectionSetDataCollectionRequestBody {
    /**
     * The updated set of data collection set members, replacing the previous set
     * @type {Array<DataCollectionSetMember>}
     * @memberof UpdateDataCollectionSetDataCollectionRequestBody
     */
    'data_collection_set_members': Array<DataCollectionSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateDiseaseEtiologicalAgentRequestBody
 */
export interface UpdateDiseaseEtiologicalAgentRequestBody {
    /**
     * 
     * @type {Array<Etiology>}
     * @memberof UpdateDiseaseEtiologicalAgentRequestBody
     */
    'etiologies': Array<Etiology>;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationIdentifierIssuerLinksRequestBody
 */
export interface UpdateOrganizationIdentifierIssuerLinksRequestBody {
    /**
     * The identifier issuers that the organization is linked to.
     * @type {Array<OrganizationIdentifierIssuerLink>}
     * @memberof UpdateOrganizationIdentifierIssuerLinksRequestBody
     */
    'organization_identifier_issuer_links': Array<OrganizationIdentifierIssuerLink>;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationSetOrganizationRequestBody
 */
export interface UpdateOrganizationSetOrganizationRequestBody {
    /**
     * The updated set of organization set members, replacing the previous set
     * @type {Array<OrganizationSetMember>}
     * @memberof UpdateOrganizationSetOrganizationRequestBody
     */
    'organization_set_members': Array<OrganizationSetMember>;
}
/**
 * 
 * @export
 * @interface UpdateUserOwnOrganizationRequestBody
 */
export interface UpdateUserOwnOrganizationRequestBody {
    /**
     * The ID of the organization to update the user to
     * @type {string}
     * @memberof UpdateUserOwnOrganizationRequestBody
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequestBody
 */
export interface UpdateUserRequestBody {
    /**
     * The updated active status of the user. Not updated if not provided.
     * @type {boolean}
     * @memberof UpdateUserRequestBody
     */
    'is_active': boolean | null;
    /**
     * The updated set of roles of the user. Not updated if not provided. If provided, should have at least one element.
     * @type {Array<string>}
     * @memberof UpdateUserRequestBody
     */
    'roles': Array<string> | null;
    /**
     * The updated organization ID of the user. Not updated if not provided.
     * @type {string}
     * @memberof UpdateUserRequestBody
     */
    'organization_id': string | null;
}
/**
 * Upload a batch of cases along with their associated data and return an upload result. The upload can be stopped after the verification step by setting the \'verify_only\' property to True, so that the returned upload result only contains the verification results.  The data are uploaded as a single atomic unit of work, so that either all data are successfully uploaded or none are.
 * @export
 * @interface UploadCasesCommand
 */
export interface UploadCasesCommand {
    /**
     * If true, the upload is only verified but not actually performed.
     * @type {boolean}
     * @memberof UploadCasesCommand
     */
    'verify_only'?: boolean;
    /**
     * 
     * @type {OnExistsUploadAction}
     * @memberof UploadCasesCommand
     */
    'on_exists'?: OnExistsUploadAction;
    /**
     * The ID of the command
     * @type {string}
     * @memberof UploadCasesCommand
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof UploadCasesCommand
     */
    'user'?: User;
    /**
     * The created timestamp of the command
     * @type {string}
     * @memberof UploadCasesCommand
     */
    'created_at'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UploadCasesCommand
     */
    'props'?: { [key: string]: any; };
    /**
     * The case type ID that all the cases must belong to. All cases in the case set must have this case type ID.
     * @type {string}
     * @memberof UploadCasesCommand
     */
    'case_type_id': string;
    /**
     * The created in data collection ID that all the cases must belong to. All cases in the case set must have this created in data collection ID.
     * @type {string}
     * @memberof UploadCasesCommand
     */
    'created_in_data_collection_id': string;
    /**
     * 
     * @type {CaseBatchForUpload}
     * @memberof UploadCasesCommand
     */
    'case_batch': CaseBatchForUpload;
}


/**
 * Represents a log item for an upload result, contain a timestamp, code, message and severity.
 * @export
 * @interface UploadLogItem
 */
export interface UploadLogItem {
    /**
     * The UTC timestamp when the log item was created.
     * @type {string}
     * @memberof UploadLogItem
     */
    'timestamp'?: string;
    /**
     * A code categorizing the log item.
     * @type {string}
     * @memberof UploadLogItem
     */
    'code': string;
    /**
     * The log message describing the event or information.
     * @type {string}
     * @memberof UploadLogItem
     */
    'message': string;
    /**
     * 
     * @type {LogLevel}
     * @memberof UploadLogItem
     */
    'severity': LogLevel;
}


/**
 * Represents the result of an upload operation, including upload status and logs.  Additional validation: - If the status is successful (NOT_FAILED), there must be no error log items. - If the status is failed, there must be at least one error log item.
 * @export
 * @interface UploadResult
 */
export interface UploadResult {
    /**
     * The unique identifier for the specific object instance that this result pertains to, if applicable. E.g. the object that was created or updated as part of the upload.
     * @type {string}
     * @memberof UploadResult
     */
    'id'?: string | null;
    /**
     * 
     * @type {UploadStatus}
     * @memberof UploadResult
     */
    'status'?: UploadStatus;
    /**
     * A list of log items capturing messages and events that occurred during the upload operation.
     * @type {Array<UploadLogItem>}
     * @memberof UploadResult
     */
    'logs'?: Array<UploadLogItem>;
}


/**
 * 
 * @export
 * @ {string}
 */

export const UploadStatus = {
    PENDING: 'PENDING',
    SKIPPED: 'SKIPPED',
    FAILED: 'FAILED',
    CREATED: 'CREATED',
    UPDATED: 'UPDATED',
    PROCESSED: 'PROCESSED'
} as const;

export type UploadStatus = typeof UploadStatus[keyof typeof UploadStatus];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * The ID of the user
     * @type {string}
     * @memberof User
     */
    'id'?: string | null;
    /**
     * The key of the user, lowercase, UNIQUE
     * @type {string}
     * @memberof User
     */
    'key': string;
    /**
     * The email of the user
     * @type {string}
     * @memberof User
     */
    'email'?: string | null;
    /**
     * The full name of the user
     * @type {string}
     * @memberof User
     */
    'name'?: string | null;
    /**
     * Whether the user is active or not. An inactive user cannot perform any actions that require authorization.
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * The roles of the user
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<string>;
    /**
     * The ID of the organization of the user. FOREIGN KEY
     * @type {string}
     * @memberof User
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof User
     */
    'organization'?: Organization;
}
/**
 * Stores the maximum access rights of a user to a particular data collection, analogous to the organization access case policy.  The actual access rights of a user are derived as the intersection of their maximum access rights stored here, and the access rights of the organization to which they belong.
 * @export
 * @interface UserAccessCasePolicy
 */
export interface UserAccessCasePolicy {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserAccessCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof UserAccessCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserAccessCasePolicy
     */
    'user'?: User;
    /**
     * The ID of the case type column set for which values can be read, limited to the case types in the case type set.  If empty, there are no read rights. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'read_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof UserAccessCasePolicy
     */
    'read_case_type_col_set'?: CaseTypeColSet;
    /**
     * The ID of the case type column set for which values can be updated, limited to the case types in the case type set.  If empty, there are no write rights. FOREIGN KEY
     * @type {string}
     * @memberof UserAccessCasePolicy
     */
    'write_case_type_col_set_id'?: string | null;
    /**
     * 
     * @type {CaseTypeColSet}
     * @memberof UserAccessCasePolicy
     */
    'write_case_type_col_set'?: CaseTypeColSet;
    /**
     * Whether case set be read, limited to the case types in the case type set
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'read_case_set': boolean;
    /**
     * Whether case set be updated, limited to the case types in the case type set
     * @type {boolean}
     * @memberof UserAccessCasePolicy
     */
    'write_case_set': boolean;
}
/**
 * Represents an invitation for a new user of a particular organization and with particular starting properties.
 * @export
 * @interface UserInvitation
 */
export interface UserInvitation {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof UserInvitation
     */
    'id'?: string | null;
    /**
     * The key of the user, lowercase, UNIQUE
     * @type {string}
     * @memberof UserInvitation
     */
    'key': string;
    /**
     * The email of the user
     * @type {string}
     * @memberof UserInvitation
     */
    'email'?: string | null;
    /**
     * The full name of the user
     * @type {string}
     * @memberof UserInvitation
     */
    'name'?: string | null;
    /**
     * The token of the invitation
     * @type {string}
     * @memberof UserInvitation
     */
    'token': string;
    /**
     * The expiry date of the invitation
     * @type {string}
     * @memberof UserInvitation
     */
    'expires_at': string;
    /**
     * The initial roles that the new user will have
     * @type {Array<string>}
     * @memberof UserInvitation
     */
    'roles': Array<string>;
    /**
     * The ID of the user who invited the new user. FOREIGN KEY
     * @type {string}
     * @memberof UserInvitation
     */
    'invited_by_user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserInvitation
     */
    'invited_by_user'?: User;
    /**
     * The ID of the organization that the new user will belong to. FOREIGN KEY
     * @type {string}
     * @memberof UserInvitation
     */
    'organization_id': string;
    /**
     * 
     * @type {Organization}
     * @memberof UserInvitation
     */
    'organization'?: Organization;
}
/**
 * Represents the constraints for a user invitation.
 * @export
 * @interface UserInvitationConstraints
 */
export interface UserInvitationConstraints {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof UserInvitationConstraints
     */
    'id'?: string | null;
    /**
     * The roles that the user may be assigned by the inviting user.
     * @type {Array<string>}
     * @memberof UserInvitationConstraints
     */
    'roles': Array<string>;
    /**
     * The organizations that the user may be assigned by the inviting user.
     * @type {Array<string>}
     * @memberof UserInvitationConstraints
     */
    'organization_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface UserInvitationRequestBody
 */
export interface UserInvitationRequestBody {
    /**
     * The key of the user, lowercase, UNIQUE
     * @type {string}
     * @memberof UserInvitationRequestBody
     */
    'key': string;
    /**
     * The initial roles that the new user will have
     * @type {Array<string>}
     * @memberof UserInvitationRequestBody
     */
    'roles': Array<string>;
    /**
     * The ID of the organization that the new user will belong to. FOREIGN KEY
     * @type {string}
     * @memberof UserInvitationRequestBody
     */
    'organization_id': string;
}
/**
 * 
 * @export
 * @interface UserNameEmail
 */
export interface UserNameEmail {
    /**
     * The ID of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'id'?: string | null;
    /**
     * The full name of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'name'?: string | null;
    /**
     * The email of the user
     * @type {string}
     * @memberof UserNameEmail
     */
    'email': string | null;
}
/**
 * Stores the maximum share rights of a user to a particular data collection, analogous to the organization share case policy.  The actual share rights of a user are derived as the intersection of their maximum share rights stored here, and the share rights of the organization to which they belong.
 * @export
 * @interface UserShareCasePolicy
 */
export interface UserShareCasePolicy {
    /**
     * The unique identifier for the object.
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'id'?: string | null;
    /**
     * The ID of the data collection. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserShareCasePolicy
     */
    'data_collection'?: DataCollection;
    /**
     * The ID of the case type set. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'case_type_set_id': string;
    /**
     * 
     * @type {CaseTypeSet}
     * @memberof UserShareCasePolicy
     */
    'case_type_set'?: CaseTypeSet;
    /**
     * Whether the right is active
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'is_active': boolean;
    /**
     * Whether cases may be added to the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'add_case': boolean;
    /**
     * Whether cases may be removed from the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'remove_case': boolean;
    /**
     * Whether case sets may be added to the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'add_case_set': boolean;
    /**
     * Whether case sets may be removed from the data collection
     * @type {boolean}
     * @memberof UserShareCasePolicy
     */
    'remove_case_set': boolean;
    /**
     * The ID of the user. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'user_id': string;
    /**
     * 
     * @type {User}
     * @memberof UserShareCasePolicy
     */
    'user'?: User;
    /**
     * The ID of the data collection from which the case type set is shared. FOREIGN KEY
     * @type {string}
     * @memberof UserShareCasePolicy
     */
    'from_data_collection_id': string;
    /**
     * 
     * @type {DataCollection}
     * @memberof UserShareCasePolicy
     */
    'from_data_collection'?: DataCollection;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * @type Value
 * The number to match.
 * @export
 */
export type Value = number | string;


/**
 * AbacApi - axios parameter creator
 * @export
 */
const AbacApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Organization Access Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post One
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostOne: async (organizationAccessCasePolicy: OrganizationAccessCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostOne', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_access_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_access_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Some
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPostSome: async (organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPostSome', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPutOne: async (objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutOne', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Access Case Policies  Put Some
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAccessCasePoliciesPutSome: async (organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAccessCasePolicy' is not null or undefined
            assertParamExists('organizationAccessCasePoliciesPutSome', 'organizationAccessCasePolicy', organizationAccessCasePolicy)
            const localVarPath = `/v1/organization_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAdminPoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationAdminPoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Post One
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostOne: async (organizationAdminPolicy: OrganizationAdminPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostOne', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_admin_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_admin_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Some
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPostSome: async (organizationAdminPolicy: Array<OrganizationAdminPolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPostSome', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPutOne: async (objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutOne', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Admin Policies  Put Some
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationAdminPoliciesPutSome: async (organizationAdminPolicy: Array<OrganizationAdminPolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationAdminPolicy' is not null or undefined
            assertParamExists('organizationAdminPoliciesPutSome', 'organizationAdminPolicy', organizationAdminPolicy)
            const localVarPath = `/v1/organization_admin_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAdminPolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationShareCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationShareCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post One
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostOne: async (organizationShareCasePolicy: OrganizationShareCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostOne', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_share_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_share_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Some
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPostSome: async (organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPostSome', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPutOne: async (objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutOne', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Share Case Policies  Put Some
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationShareCasePoliciesPutSome: async (organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationShareCasePolicy' is not null or undefined
            assertParamExists('organizationShareCasePoliciesPutSome', 'organizationShareCasePolicy', organizationShareCasePolicy)
            const localVarPath = `/v1/organization_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the names and email addresses of all organization admins for the user\'s organization.
         * @summary Retrieveorganizationadminnameemailscommand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationAdminNameEmails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve_organization_admin_name_emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userAccessCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userAccessCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Post One
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostOne: async (userAccessCasePolicy: UserAccessCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostOne', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_access_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_access_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Post Some
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPostSome: async (userAccessCasePolicy: Array<UserAccessCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPostSome', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Put One
         * @param {string} objectId 
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPutOne: async (objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutOne', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Access Case Policies  Put Some
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccessCasePoliciesPutSome: async (userAccessCasePolicy: Array<UserAccessCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccessCasePolicy' is not null or undefined
            assertParamExists('userAccessCasePoliciesPutSome', 'userAccessCasePolicy', userAccessCasePolicy)
            const localVarPath = `/v1/user_access_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAccessCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userShareCasePoliciesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userShareCasePoliciesGetSome', 'ids', ids)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Post One
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostOne: async (userShareCasePolicy: UserShareCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPostOne', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userShareCasePoliciesPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_share_case_policies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userShareCasePoliciesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_share_case_policies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Post Some
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPostSome: async (userShareCasePolicy: Array<UserShareCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPostSome', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Put One
         * @param {string} objectId 
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPutOne: async (objectId: string, userShareCasePolicy: UserShareCasePolicy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userShareCasePoliciesPutOne', 'objectId', objectId)
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPutOne', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Share Case Policies  Put Some
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareCasePoliciesPutSome: async (userShareCasePolicy: Array<UserShareCasePolicy>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userShareCasePolicy' is not null or undefined
            assertParamExists('userShareCasePoliciesPutSome', 'userShareCasePolicy', userShareCasePolicy)
            const localVarPath = `/v1/user_share_case_policies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userShareCasePolicy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AbacApi - functional programming interface
 * @export
 */
const AbacApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AbacApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Organization Access Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post One
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Post Some
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPutOne(objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPutOne(objectId, organizationAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Access Case Policies  Put Some
         * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAccessCasePoliciesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Post One
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostOne(organizationAdminPolicy: OrganizationAdminPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostOne(organizationAdminPolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Post Some
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPostSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPostSome(organizationAdminPolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationAdminPolicy} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPutOne(objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAdminPolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPutOne(objectId, organizationAdminPolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Admin Policies  Put Some
         * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationAdminPoliciesPutSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationAdminPolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationAdminPoliciesPutSome(organizationAdminPolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationAdminPoliciesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post One
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostOne(organizationShareCasePolicy: OrganizationShareCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostOne(organizationShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Post Some
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPostSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPostSome(organizationShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Put One
         * @param {string} objectId 
         * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPutOne(objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPutOne(objectId, organizationShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Share Case Policies  Put Some
         * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationShareCasePoliciesPutSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationShareCasePoliciesPutSome(organizationShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.organizationShareCasePoliciesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the names and email addresses of all organization admins for the user\'s organization.
         * @summary Retrieveorganizationadminnameemailscommand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrganizationAdminNameEmails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserNameEmail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrganizationAdminNameEmails(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.retrieveOrganizationAdminNameEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Post One
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostOne(userAccessCasePolicy: UserAccessCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostOne(userAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Post Some
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPostSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPostSome(userAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Put One
         * @param {string} objectId 
         * @param {UserAccessCasePolicy} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPutOne(objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccessCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPutOne(objectId, userAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Access Case Policies  Put Some
         * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccessCasePoliciesPutSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAccessCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccessCasePoliciesPutSome(userAccessCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userAccessCasePoliciesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Post One
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostOne(userShareCasePolicy: UserShareCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostOne(userShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Post Some
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPostSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPostSome(userShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Put One
         * @param {string} objectId 
         * @param {UserShareCasePolicy} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPutOne(objectId: string, userShareCasePolicy: UserShareCasePolicy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserShareCasePolicy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPutOne(objectId, userShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Share Case Policies  Put Some
         * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareCasePoliciesPutSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserShareCasePolicy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareCasePoliciesPutSome(userShareCasePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AbacApi.userShareCasePoliciesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AbacApi - factory interface
 * @export
 */

/**
 * AbacApi - object-oriented interface

 * @export
 * @class AbacApi
 * @extends {BaseAPI}
 */
export class AbacApi extends BaseAPI {
  private static __instance: AbacApi;
  public static get instance(): AbacApi {
    AbacApi.__instance = AbacApi.__instance || new AbacApi();
    return AbacApi.__instance;
  }

    /**
     * 
     * @summary Organization Access Case Policies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Post One
     * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostOne(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Post Some
     * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPostSome(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Put One
     * @param {string} objectId 
     * @param {OrganizationAccessCasePolicy} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPutOne(objectId: string, organizationAccessCasePolicy: OrganizationAccessCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPutOne(objectId, organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Access Case Policies  Put Some
     * @param {Array<OrganizationAccessCasePolicy>} organizationAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy: Array<OrganizationAccessCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAccessCasePoliciesPutSome(organizationAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Post One
     * @param {OrganizationAdminPolicy} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostOne(organizationAdminPolicy: OrganizationAdminPolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostOne(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Post Some
     * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPostSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPostSome(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Put One
     * @param {string} objectId 
     * @param {OrganizationAdminPolicy} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPutOne(objectId: string, organizationAdminPolicy: OrganizationAdminPolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPutOne(objectId, organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Admin Policies  Put Some
     * @param {Array<OrganizationAdminPolicy>} organizationAdminPolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationAdminPoliciesPutSome(organizationAdminPolicy: Array<OrganizationAdminPolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationAdminPoliciesPutSome(organizationAdminPolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Post One
     * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostOne(organizationShareCasePolicy: OrganizationShareCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostOne(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Post Some
     * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPostSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPostSome(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Put One
     * @param {string} objectId 
     * @param {OrganizationShareCasePolicy} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPutOne(objectId: string, organizationShareCasePolicy: OrganizationShareCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPutOne(objectId, organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Share Case Policies  Put Some
     * @param {Array<OrganizationShareCasePolicy>} organizationShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public organizationShareCasePoliciesPutSome(organizationShareCasePolicy: Array<OrganizationShareCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).organizationShareCasePoliciesPutSome(organizationShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve the names and email addresses of all organization admins for the user\'s organization.
     * @summary Retrieveorganizationadminnameemailscommand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public retrieveOrganizationAdminNameEmails(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).retrieveOrganizationAdminNameEmails(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Post One
     * @param {UserAccessCasePolicy} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostOne(userAccessCasePolicy: UserAccessCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostOne(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Post Some
     * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPostSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPostSome(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Put One
     * @param {string} objectId 
     * @param {UserAccessCasePolicy} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPutOne(objectId: string, userAccessCasePolicy: UserAccessCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPutOne(objectId, userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Access Case Policies  Put Some
     * @param {Array<UserAccessCasePolicy>} userAccessCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userAccessCasePoliciesPutSome(userAccessCasePolicy: Array<UserAccessCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userAccessCasePoliciesPutSome(userAccessCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetAll(options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Post One
     * @param {UserShareCasePolicy} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostOne(userShareCasePolicy: UserShareCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostOne(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Post Some
     * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPostSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPostSome(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Put One
     * @param {string} objectId 
     * @param {UserShareCasePolicy} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPutOne(objectId: string, userShareCasePolicy: UserShareCasePolicy, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPutOne(objectId, userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Share Case Policies  Put Some
     * @param {Array<UserShareCasePolicy>} userShareCasePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AbacApi
     */
    public userShareCasePoliciesPutSome(userShareCasePolicy: Array<UserShareCasePolicy>, options?: RawAxiosRequestConfig) {
        return AbacApiFp(this.configuration).userShareCasePoliciesPutSome(userShareCasePolicy, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all public identity providers
         * @summary Identityprovider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identityProvidersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identity_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all public identity providers
         * @summary Identityprovider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identityProvidersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentityProvider>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identityProvidersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.identityProvidersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */

/**
 * AuthApi - object-oriented interface

 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  private static __instance: AuthApi;
  public static get instance(): AuthApi {
    AuthApi.__instance = AuthApi.__instance || new AuthApi();
    return AuthApi.__instance;
  }

    /**
     * Get all public identity providers
     * @summary Identityprovider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public identityProvidersGetAll(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).identityProvidersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * CaseApi - axios parameter creator
 * @export
 */
const CaseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Case Data Collection Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseDataCollectionLinksDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseDataCollectionLinksGetSome', 'ids', ids)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Post One
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostOne: async (caseDataCollectionLink: CaseDataCollectionLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostOne', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_data_collection_links/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_data_collection_links/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Some
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPostSome: async (caseDataCollectionLink: Array<CaseDataCollectionLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPostSome', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Put One
         * @param {string} objectId 
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPutOne: async (objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutOne', 'objectId', objectId)
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutOne', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Data Collection Links  Put Some
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseDataCollectionLinksPutSome: async (caseDataCollectionLink: Array<CaseDataCollectionLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseDataCollectionLink' is not null or undefined
            assertParamExists('caseDataCollectionLinksPutSome', 'caseDataCollectionLink', caseDataCollectionLink)
            const localVarPath = `/v1/case_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetCategoriesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetCategoriesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Post One
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostOne: async (caseSetCategory: CaseSetCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPostOne', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetCategoriesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_categories/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetCategoriesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_categories/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Post Some
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPostSome: async (caseSetCategory: Array<CaseSetCategory>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPostSome', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Put One
         * @param {string} objectId 
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPutOne: async (objectId: string, caseSetCategory: CaseSetCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetCategoriesPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPutOne', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Categories  Put Some
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetCategoriesPutSome: async (caseSetCategory: Array<CaseSetCategory>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetCategory' is not null or undefined
            assertParamExists('caseSetCategoriesPutSome', 'caseSetCategory', caseSetCategory)
            const localVarPath = `/v1/case_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post One
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostOne: async (caseSetDataCollectionLink: CaseSetDataCollectionLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostOne', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_data_collection_links/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_data_collection_links/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Some
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPostSome: async (caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPostSome', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Put One
         * @param {string} objectId 
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPutOne: async (objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutOne', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Put Some
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetDataCollectionLinksPutSome: async (caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetDataCollectionLink' is not null or undefined
            assertParamExists('caseSetDataCollectionLinksPutSome', 'caseSetDataCollectionLink', caseSetDataCollectionLink)
            const localVarPath = `/v1/case_set_data_collection_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetDataCollectionLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Post One
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostOne: async (caseSetMember: CaseSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPostOne', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Post Some
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPostSome: async (caseSetMember: Array<CaseSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPostSome', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Put One
         * @param {string} objectId 
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPutOne: async (objectId: string, caseSetMember: CaseSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPutOne', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Members  Put Some
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetMembersPutSome: async (caseSetMember: Array<CaseSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetMember' is not null or undefined
            assertParamExists('caseSetMembersPutSome', 'caseSetMember', caseSetMember)
            const localVarPath = `/v1/case_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetStatusesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetStatusesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Post One
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostOne: async (caseSetStatus: CaseSetStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPostOne', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetStatusesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_set_statuses/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetStatusesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_set_statuses/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Post Some
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPostSome: async (caseSetStatus: Array<CaseSetStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPostSome', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Put One
         * @param {string} objectId 
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPutOne: async (objectId: string, caseSetStatus: CaseSetStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetStatusesPutOne', 'objectId', objectId)
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPutOne', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Set Statuses  Put Some
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetStatusesPutSome: async (caseSetStatus: Array<CaseSetStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSetStatus' is not null or undefined
            assertParamExists('caseSetStatusesPutSome', 'caseSetStatus', caseSetStatus)
            const localVarPath = `/v1/case_set_statuses/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSetStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Post One
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostOne: async (caseSet: CaseSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPostOne', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Post Some
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPostSome: async (caseSet: Array<CaseSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPostSome', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Put One
         * @param {string} objectId 
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPutOne: async (objectId: string, caseSet: CaseSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPutOne', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Sets  Put Some
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseSetsPutSome: async (caseSet: Array<CaseSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseSet' is not null or undefined
            assertParamExists('caseSetsPutSome', 'caseSet', caseSet)
            const localVarPath = `/v1/case_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post One
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostOne: async (caseTypeColSetMember: CaseTypeColSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostOne', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_col_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_col_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Some
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPostSome: async (caseTypeColSetMember: Array<CaseTypeColSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPostSome', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Put One
         * @param {string} objectId 
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPutOne: async (objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutOne', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Set Members  Put Some
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetMembersPutSome: async (caseTypeColSetMember: Array<CaseTypeColSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetMember' is not null or undefined
            assertParamExists('caseTypeColSetMembersPutSome', 'caseTypeColSetMember', caseTypeColSetMember)
            const localVarPath = `/v1/case_type_col_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Post One
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostOne: async (caseTypeColSet: CaseTypeColSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPostOne', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_col_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_col_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Some
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPostSome: async (caseTypeColSet: Array<CaseTypeColSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPostSome', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Association Between Casetypecolset And Casetypecol
         * @param {string} caseTypeColSetId 
         * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutCaseTypeCols: async (caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSetId' is not null or undefined
            assertParamExists('caseTypeColSetsPutCaseTypeCols', 'caseTypeColSetId', caseTypeColSetId)
            // verify required parameter 'updateCaseTypeColSetCaseTypeColsRequestBody' is not null or undefined
            assertParamExists('caseTypeColSetsPutCaseTypeCols', 'updateCaseTypeColSetCaseTypeColsRequestBody', updateCaseTypeColSetCaseTypeColsRequestBody)
            const localVarPath = `/v1/case_type_col_sets/{case_type_col_set_id}/case_type_cols`
                .replace(`{${"case_type_col_set_id"}}`, encodeURIComponent(String(caseTypeColSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseTypeColSetCaseTypeColsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Put One
         * @param {string} objectId 
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutOne: async (objectId: string, caseTypeColSet: CaseTypeColSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPutOne', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Col Sets  Put Some
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColSetsPutSome: async (caseTypeColSet: Array<CaseTypeColSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeColSet' is not null or undefined
            assertParamExists('caseTypeColSetsPutSome', 'caseTypeColSet', caseTypeColSet)
            const localVarPath = `/v1/case_type_col_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeColSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeColsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Post One
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostOne: async (caseTypeCol: CaseTypeCol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPostOne', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_cols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeColsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_cols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Post Some
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPostSome: async (caseTypeCol: Array<CaseTypeCol>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPostSome', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Put One
         * @param {string} objectId 
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPutOne: async (objectId: string, caseTypeCol: CaseTypeCol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeColsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPutOne', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Cols  Put Some
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeColsPutSome: async (caseTypeCol: Array<CaseTypeCol>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeCol' is not null or undefined
            assertParamExists('caseTypeColsPutSome', 'caseTypeCol', caseTypeCol)
            const localVarPath = `/v1/case_type_cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeCol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeDimsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeDimsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeDimsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeDimsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Post One
         * @param {CaseTypeDim} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPostOne: async (caseTypeDim: CaseTypeDim, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeDim' is not null or undefined
            assertParamExists('caseTypeDimsPostOne', 'caseTypeDim', caseTypeDim)
            const localVarPath = `/v1/case_type_dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeDim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeDimsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_dims/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeDimsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_dims/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Post Some
         * @param {Array<CaseTypeDim>} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPostSome: async (caseTypeDim: Array<CaseTypeDim>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeDim' is not null or undefined
            assertParamExists('caseTypeDimsPostSome', 'caseTypeDim', caseTypeDim)
            const localVarPath = `/v1/case_type_dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeDim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Put One
         * @param {string} objectId 
         * @param {CaseTypeDim} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPutOne: async (objectId: string, caseTypeDim: CaseTypeDim, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeDimsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeDim' is not null or undefined
            assertParamExists('caseTypeDimsPutOne', 'caseTypeDim', caseTypeDim)
            const localVarPath = `/v1/case_type_dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeDim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Dims  Put Some
         * @param {Array<CaseTypeDim>} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeDimsPutSome: async (caseTypeDim: Array<CaseTypeDim>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeDim' is not null or undefined
            assertParamExists('caseTypeDimsPutSome', 'caseTypeDim', caseTypeDim)
            const localVarPath = `/v1/case_type_dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeDim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetCategoriesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetCategoriesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Post One
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostOne: async (caseTypeSetCategory: CaseTypeSetCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostOne', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_set_categories/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_set_categories/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Some
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPostSome: async (caseTypeSetCategory: Array<CaseTypeSetCategory>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPostSome', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Put One
         * @param {string} objectId 
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPutOne: async (objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutOne', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Categories  Put Some
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetCategoriesPutSome: async (caseTypeSetCategory: Array<CaseTypeSetCategory>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetCategory' is not null or undefined
            assertParamExists('caseTypeSetCategoriesPutSome', 'caseTypeSetCategory', caseTypeSetCategory)
            const localVarPath = `/v1/case_type_set_categories/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Post One
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostOne: async (caseTypeSetMember: CaseTypeSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPostOne', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Post Some
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPostSome: async (caseTypeSetMember: Array<CaseTypeSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPostSome', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Put One
         * @param {string} objectId 
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPutOne: async (objectId: string, caseTypeSetMember: CaseTypeSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPutOne', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Set Members  Put Some
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetMembersPutSome: async (caseTypeSetMember: Array<CaseTypeSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetMember' is not null or undefined
            assertParamExists('caseTypeSetMembersPutSome', 'caseTypeSetMember', caseTypeSetMember)
            const localVarPath = `/v1/case_type_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypeSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Post One
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostOne: async (caseTypeSet: CaseTypeSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPostOne', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_type_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypeSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_type_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Post Some
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPostSome: async (caseTypeSet: Array<CaseTypeSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPostSome', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Association Between Casetypeset And Casetype
         * @param {string} caseTypeSetId 
         * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutCaseTypes: async (caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSetId' is not null or undefined
            assertParamExists('caseTypeSetsPutCaseTypes', 'caseTypeSetId', caseTypeSetId)
            // verify required parameter 'updateCaseTypeSetCaseTypesRequestBody' is not null or undefined
            assertParamExists('caseTypeSetsPutCaseTypes', 'updateCaseTypeSetCaseTypesRequestBody', updateCaseTypeSetCaseTypesRequestBody)
            const localVarPath = `/v1/case_type_sets/{case_type_set_id}/case_types`
                .replace(`{${"case_type_set_id"}}`, encodeURIComponent(String(caseTypeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCaseTypeSetCaseTypesRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Put One
         * @param {string} objectId 
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutOne: async (objectId: string, caseTypeSet: CaseTypeSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypeSetsPutOne', 'objectId', objectId)
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPutOne', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Type Sets  Put Some
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypeSetsPutSome: async (caseTypeSet: Array<CaseTypeSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeSet' is not null or undefined
            assertParamExists('caseTypeSetsPutSome', 'caseTypeSet', caseTypeSet)
            const localVarPath = `/v1/case_type_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseTypeSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('caseTypesGetSome', 'ids', ids)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Post One
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostOne: async (caseType: CaseType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPostOne', 'caseType', caseType)
            const localVarPath = `/v1/case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypesPostQuery', 'filter', filter)
            const localVarPath = `/v1/case_types/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('caseTypesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/case_types/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Post Some
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPostSome: async (caseType: Array<CaseType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPostSome', 'caseType', caseType)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Put One
         * @param {string} objectId 
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPutOne: async (objectId: string, caseType: CaseType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('caseTypesPutOne', 'objectId', objectId)
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPutOne', 'caseType', caseType)
            const localVarPath = `/v1/case_types/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Case Types  Put Some
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        caseTypesPutSome: async (caseType: Array<CaseType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseType' is not null or undefined
            assertParamExists('caseTypesPutSome', 'caseType', caseType)
            const localVarPath = `/v1/case_types/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('casesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('casesGetSome', 'ids', ids)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Post One
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostOne: async (_case: Case, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPostOne', '_case', _case)
            const localVarPath = `/v1/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('casesPostQuery', 'filter', filter)
            const localVarPath = `/v1/cases/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('casesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/cases/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Post Some
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPostSome: async (_case: Array<Case>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPostSome', '_case', _case)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Put One
         * @param {string} objectId 
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPutOne: async (objectId: string, _case: Case, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('casesPutOne', 'objectId', objectId)
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPutOne', '_case', _case)
            const localVarPath = `/v1/cases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cases  Put Some
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPutSome: async (_case: Array<Case>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter '_case' is not null or undefined
            assertParamExists('casesPutSome', '_case', _case)
            const localVarPath = `/v1/cases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(_case, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('colsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('colsGetSome', 'ids', ids)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Post One
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostOne: async (col: Col, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPostOne', 'col', col)
            const localVarPath = `/v1/cols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('colsPostQuery', 'filter', filter)
            const localVarPath = `/v1/cols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('colsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/cols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Post Some
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPostSome: async (col: Array<Col>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPostSome', 'col', col)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Put One
         * @param {string} objectId 
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPutOne: async (objectId: string, col: Col, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('colsPutOne', 'objectId', objectId)
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPutOne', 'col', col)
            const localVarPath = `/v1/cols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cols  Put Some
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsPutSome: async (col: Array<Col>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'col' is not null or undefined
            assertParamExists('colsPutSome', 'col', col)
            const localVarPath = `/v1/cols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(col, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The additional validation rules that a Col instance must comply with.
         * @summary Col Validation Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        colsValidationRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cols/validation_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a complete case type.
         * @summary Retrieve Complete Case Type
         * @param {string} caseTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeCaseTypesGetOne: async (caseTypeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseTypeId' is not null or undefined
            assertParamExists('completeCaseTypesGetOne', 'caseTypeId', caseTypeId)
            const localVarPath = `/v1/complete_case_types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (caseTypeId !== undefined) {
                localVarQueryParameter['case_type_id'] = caseTypeId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new case set and associate it with the specified data collections and cases.
         * @summary Create Case Set
         * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCaseSet: async (createCaseSetRequestBody: CreateCaseSetRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCaseSetRequestBody' is not null or undefined
            assertParamExists('createCaseSet', 'createCaseSetRequestBody', createCaseSetRequestBody)
            const localVarPath = `/v1/create/case_set`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCaseSetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a file for a read set associated with a case.
         * @summary Create File For Reads Set
         * @param {string} caseId 
         * @param {string} caseTypeColId 
         * @param {CreateFileForReadSetRequestBody} createFileForReadSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileForReadSet: async (caseId: string, caseTypeColId: string, createFileForReadSetRequestBody: CreateFileForReadSetRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('createFileForReadSet', 'caseId', caseId)
            // verify required parameter 'caseTypeColId' is not null or undefined
            assertParamExists('createFileForReadSet', 'caseTypeColId', caseTypeColId)
            // verify required parameter 'createFileForReadSetRequestBody' is not null or undefined
            assertParamExists('createFileForReadSet', 'createFileForReadSetRequestBody', createFileForReadSetRequestBody)
            const localVarPath = `/v1/create_file_for_read_set/{case_id}/{case_type_col_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"case_type_col_id"}}`, encodeURIComponent(String(caseTypeColId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileForReadSetRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a file for a sequence associated with a case.
         * @summary Create File For Sequence
         * @param {string} caseId 
         * @param {string} caseTypeColId 
         * @param {CreateFileForSeqRequestBody} createFileForSeqRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFileForSeq: async (caseId: string, caseTypeColId: string, createFileForSeqRequestBody: CreateFileForSeqRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseId' is not null or undefined
            assertParamExists('createFileForSeq', 'caseId', caseId)
            // verify required parameter 'caseTypeColId' is not null or undefined
            assertParamExists('createFileForSeq', 'caseTypeColId', caseTypeColId)
            // verify required parameter 'createFileForSeqRequestBody' is not null or undefined
            assertParamExists('createFileForSeq', 'createFileForSeqRequestBody', createFileForSeqRequestBody)
            const localVarPath = `/v1/create_file_for_seq/{case_id}/{case_type_col_id}`
                .replace(`{${"case_id"}}`, encodeURIComponent(String(caseId)))
                .replace(`{${"case_type_col_id"}}`, encodeURIComponent(String(caseTypeColId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFileForSeqRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dimsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dimsGetSome', 'ids', ids)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Post One
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostOne: async (dim: Dim, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPostOne', 'dim', dim)
            const localVarPath = `/v1/dims`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dimsPostQuery', 'filter', filter)
            const localVarPath = `/v1/dims/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dimsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/dims/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Post Some
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPostSome: async (dim: Array<Dim>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPostSome', 'dim', dim)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Put One
         * @param {string} objectId 
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPutOne: async (objectId: string, dim: Dim, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dimsPutOne', 'objectId', objectId)
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPutOne', 'dim', dim)
            const localVarPath = `/v1/dims/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Dims  Put Some
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dimsPutSome: async (dim: Array<Dim>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dim' is not null or undefined
            assertParamExists('dimsPutSome', 'dim', dim)
            const localVarPath = `/v1/dims/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dim, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('geneticDistanceProtocolsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('geneticDistanceProtocolsGetSome', 'ids', ids)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post One
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostOne: async (geneticDistanceProtocol: GeneticDistanceProtocol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostOne', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostQuery', 'filter', filter)
            const localVarPath = `/v1/genetic_distance_protocols/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/genetic_distance_protocols/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Some
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPostSome: async (geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPostSome', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Put One
         * @param {string} objectId 
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPutOne: async (objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutOne', 'objectId', objectId)
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutOne', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Put Some
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geneticDistanceProtocolsPutSome: async (geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'geneticDistanceProtocol' is not null or undefined
            assertParamExists('geneticDistanceProtocolsPutSome', 'geneticDistanceProtocol', geneticDistanceProtocol)
            const localVarPath = `/v1/genetic_distance_protocols/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(geneticDistanceProtocol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve assembly protocols from seqdb database
         * @summary Retrieve Assembly Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAssemblyProtocols: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/assembly_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases based on a query.
         * @summary Retrieve Case Ids By Query
         * @param {CaseQuery} caseQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseIdsByQuery: async (caseQuery: CaseQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'caseQuery' is not null or undefined
            assertParamExists('retrieveCaseIdsByQuery', 'caseQuery', caseQuery)
            const localVarPath = `/v1/retrieve/case_ids_by_query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(caseQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve access rights for a set of cases.
         * @summary Retrieve Case Rights
         * @param {RetrieveCaseRightsRequestBody} retrieveCaseRightsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseRights: async (retrieveCaseRightsRequestBody: RetrieveCaseRightsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveCaseRightsRequestBody' is not null or undefined
            assertParamExists('retrieveCaseRights', 'retrieveCaseRightsRequestBody', retrieveCaseRightsRequestBody)
            const localVarPath = `/v1/retrieve/case_rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveCaseRightsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve access rights for a set of case sets.
         * @summary Retrieve Case Set Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseSetRights: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('retrieveCaseSetRights', 'requestBody', requestBody)
            const localVarPath = `/v1/retrieve/case_set_rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
         * @summary Retrieve Case Set Statistics
         * @param {RetrieveCaseSetStatsRequestBody} retrieveCaseSetStatsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseSetStats: async (retrieveCaseSetStatsRequestBody: RetrieveCaseSetStatsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveCaseSetStatsRequestBody' is not null or undefined
            assertParamExists('retrieveCaseSetStats', 'retrieveCaseSetStatsRequestBody', retrieveCaseSetStatsRequestBody)
            const localVarPath = `/v1/retrieve/case_set_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveCaseSetStatsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
         * @summary Retrieve Case Type Statistics
         * @param {RetrieveCaseTypeStatsRequestBody} retrieveCaseTypeStatsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCaseTypeStats: async (retrieveCaseTypeStatsRequestBody: RetrieveCaseTypeStatsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveCaseTypeStatsRequestBody' is not null or undefined
            assertParamExists('retrieveCaseTypeStats', 'retrieveCaseTypeStatsRequestBody', retrieveCaseTypeStatsRequestBody)
            const localVarPath = `/v1/retrieve/case_type_stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveCaseTypeStatsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve cases by their IDs.
         * @summary Retrieve Cases By Ids
         * @param {RetrieveCasesByIdsRequestBody} retrieveCasesByIdsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCasesByIds: async (retrieveCasesByIdsRequestBody: RetrieveCasesByIdsRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveCasesByIdsRequestBody' is not null or undefined
            assertParamExists('retrieveCasesByIds', 'retrieveCasesByIdsRequestBody', retrieveCasesByIdsRequestBody)
            const localVarPath = `/v1/retrieve/cases_by_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveCasesByIdsRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a set of genetic sequences based on a set of case IDs and a genetic sequence case type column.
         * @summary Retrieve Genetic Sequence By Case
         * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGeneticSequence: async (retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveGeneticSequenceRequestBody' is not null or undefined
            assertParamExists('retrieveGeneticSequence', 'retrieveGeneticSequenceRequestBody', retrieveGeneticSequenceRequestBody)
            const localVarPath = `/v1/retrieve/genetic_sequence`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveGeneticSequenceRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a set of genetic sequences in FASTA format based on a set of case IDs and a genetic sequence case type column. An iterator is returned that yields the FASTA lines.
         * @summary Retrieve Genetic Sequence By Case, In Fasta Format And Streamed
         * @param {string} token 
         * @param {string} caseTypeId 
         * @param {string} geneticSequenceCaseTypeColId 
         * @param {Array<string>} caseIds 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGeneticSequenceFasta: async (token: string, caseTypeId: string, geneticSequenceCaseTypeColId: string, caseIds: Array<string>, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveGeneticSequenceFasta', 'token', token)
            // verify required parameter 'caseTypeId' is not null or undefined
            assertParamExists('retrieveGeneticSequenceFasta', 'caseTypeId', caseTypeId)
            // verify required parameter 'geneticSequenceCaseTypeColId' is not null or undefined
            assertParamExists('retrieveGeneticSequenceFasta', 'geneticSequenceCaseTypeColId', geneticSequenceCaseTypeColId)
            // verify required parameter 'caseIds' is not null or undefined
            assertParamExists('retrieveGeneticSequenceFasta', 'caseIds', caseIds)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('retrieveGeneticSequenceFasta', 'fileName', fileName)
            const localVarPath = `/v1/retrieve/genetic_sequence/fasta`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
            if (caseTypeId !== undefined) { 
                localVarFormParams.set('case_type_id', caseTypeId as any);
            }
    
            if (geneticSequenceCaseTypeColId !== undefined) { 
                localVarFormParams.set('genetic_sequence_case_type_col_id', geneticSequenceCaseTypeColId as any);
            }
                if (caseIds) {
                localVarFormParams.set('case_ids', caseIds.join(COLLECTION_FORMATS.csv));
            }

    
            if (fileName !== undefined) { 
                localVarFormParams.set('file_name', fileName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Contacts associated with organizations, sites, or specific contacts.  Exactly one of organization_ids, site_ids, or contact_ids must be provided. Returns a list of contacts with their associated site and organization data cascaded.
         * @summary Retrieve Organization Contact
         * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOrganizationContact: async (retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrieveOrganizationContactRequestBody' is not null or undefined
            assertParamExists('retrieveOrganizationContact', 'retrieveOrganizationContactRequestBody', retrieveOrganizationContactRequestBody)
            const localVarPath = `/v1/retrieve/organization_contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrieveOrganizationContactRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a phylogenetic tree based on a set of case IDs, a tree algorithm, and a genetic distance case type column.
         * @summary Retrieve Phylogenetic Tree
         * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePhylogeneticTree: async (retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'retrievePhylogeneticTreeRequestBody' is not null or undefined
            assertParamExists('retrievePhylogeneticTree', 'retrievePhylogeneticTreeRequestBody', retrievePhylogeneticTreeRequestBody)
            const localVarPath = `/v1/retrieve/phylogenetic_tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retrievePhylogeneticTreeRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve sequencing protocols from seqdb database
         * @summary Retrieve Sequencing Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSequencingProtocols: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/sequencing_protocols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmClassesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmClassesGetSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post One
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostOne: async (treeAlgorithmClass: TreeAlgorithmClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostOne', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostQuery', 'filter', filter)
            const localVarPath = `/v1/tree_algorithm_classes/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/tree_algorithm_classes/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Some
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPostSome: async (treeAlgorithmClass: Array<TreeAlgorithmClass>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPostSome', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Put One
         * @param {string} objectId 
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPutOne: async (objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutOne', 'objectId', objectId)
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutOne', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Put Some
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmClassesPutSome: async (treeAlgorithmClass: Array<TreeAlgorithmClass>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithmClass' is not null or undefined
            assertParamExists('treeAlgorithmClassesPutSome', 'treeAlgorithmClass', treeAlgorithmClass)
            const localVarPath = `/v1/tree_algorithm_classes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithmClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('treeAlgorithmsGetSome', 'ids', ids)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Post One
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostOne: async (treeAlgorithm: TreeAlgorithm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPostOne', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmsPostQuery', 'filter', filter)
            const localVarPath = `/v1/tree_algorithms/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('treeAlgorithmsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/tree_algorithms/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Post Some
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPostSome: async (treeAlgorithm: Array<TreeAlgorithm>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPostSome', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Put One
         * @param {string} objectId 
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPutOne: async (objectId: string, treeAlgorithm: TreeAlgorithm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('treeAlgorithmsPutOne', 'objectId', objectId)
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPutOne', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Tree Algorithms  Put Some
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        treeAlgorithmsPutSome: async (treeAlgorithm: Array<TreeAlgorithm>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'treeAlgorithm' is not null or undefined
            assertParamExists('treeAlgorithmsPutSome', 'treeAlgorithm', treeAlgorithm)
            const localVarPath = `/v1/tree_algorithms/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(treeAlgorithm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a batch of cases along with their associated data and return an upload result. The upload can be stopped after the verification step by setting the \'verify_only\' property to True, so that the returned upload result only contains the verification results.  The data are uploaded as a single atomic unit of work, so that either all data are successfully uploaded or none are.
         * @summary Upload Cases
         * @param {UploadCasesCommand} uploadCasesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCases: async (uploadCasesCommand: UploadCasesCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadCasesCommand' is not null or undefined
            assertParamExists('uploadCases', 'uploadCasesCommand', uploadCasesCommand)
            const localVarPath = `/v1/upload/cases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadCasesCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CaseApi - functional programming interface
 * @export
 */
const CaseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CaseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Case Data Collection Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Post One
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostOne(caseDataCollectionLink: CaseDataCollectionLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostOne(caseDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Post Some
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPostSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPostSome(caseDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Put One
         * @param {string} objectId 
         * @param {CaseDataCollectionLink} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPutOne(objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPutOne(objectId, caseDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Data Collection Links  Put Some
         * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseDataCollectionLinksPutSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseDataCollectionLinksPutSome(caseDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseDataCollectionLinksPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Post One
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostOne(caseSetCategory: CaseSetCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostOne(caseSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Post Some
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPostSome(caseSetCategory: Array<CaseSetCategory>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPostSome(caseSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Put One
         * @param {string} objectId 
         * @param {CaseSetCategory} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPutOne(objectId: string, caseSetCategory: CaseSetCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPutOne(objectId, caseSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Categories  Put Some
         * @param {Array<CaseSetCategory>} caseSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetCategoriesPutSome(caseSetCategory: Array<CaseSetCategory>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetCategoriesPutSome(caseSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetCategoriesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post One
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Post Some
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Put One
         * @param {string} objectId 
         * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPutOne(objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetDataCollectionLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPutOne(objectId, caseSetDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Data Collection Links  Put Some
         * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetDataCollectionLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetDataCollectionLinksPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Post One
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostOne(caseSetMember: CaseSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostOne(caseSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Post Some
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPostSome(caseSetMember: Array<CaseSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPostSome(caseSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Put One
         * @param {string} objectId 
         * @param {CaseSetMember} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPutOne(objectId: string, caseSetMember: CaseSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPutOne(objectId, caseSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Members  Put Some
         * @param {Array<CaseSetMember>} caseSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetMembersPutSome(caseSetMember: Array<CaseSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetMembersPutSome(caseSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetMembersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Post One
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostOne(caseSetStatus: CaseSetStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostOne(caseSetStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Post Some
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPostSome(caseSetStatus: Array<CaseSetStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPostSome(caseSetStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Put One
         * @param {string} objectId 
         * @param {CaseSetStatus} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPutOne(objectId: string, caseSetStatus: CaseSetStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPutOne(objectId, caseSetStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Set Statuses  Put Some
         * @param {Array<CaseSetStatus>} caseSetStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetStatusesPutSome(caseSetStatus: Array<CaseSetStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetStatusesPutSome(caseSetStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetStatusesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Post One
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostOne(caseSet: CaseSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostOne(caseSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Post Some
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPostSome(caseSet: Array<CaseSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPostSome(caseSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Put One
         * @param {string} objectId 
         * @param {CaseSet} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPutOne(objectId: string, caseSet: CaseSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPutOne(objectId, caseSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Sets  Put Some
         * @param {Array<CaseSet>} caseSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseSetsPutSome(caseSet: Array<CaseSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseSetsPutSome(caseSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post One
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostOne(caseTypeColSetMember: CaseTypeColSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostOne(caseTypeColSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Post Some
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPostSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPostSome(caseTypeColSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Put One
         * @param {string} objectId 
         * @param {CaseTypeColSetMember} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPutOne(objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPutOne(objectId, caseTypeColSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Set Members  Put Some
         * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetMembersPutSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetMembersPutSome(caseTypeColSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetMembersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Post One
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostOne(caseTypeColSet: CaseTypeColSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostOne(caseTypeColSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Post Some
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPostSome(caseTypeColSet: Array<CaseTypeColSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPostSome(caseTypeColSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Association Between Casetypecolset And Casetypecol
         * @param {string} caseTypeColSetId 
         * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutCaseTypeCols(caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutCaseTypeCols(caseTypeColSetId, updateCaseTypeColSetCaseTypeColsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPutCaseTypeCols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Put One
         * @param {string} objectId 
         * @param {CaseTypeColSet} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutOne(objectId: string, caseTypeColSet: CaseTypeColSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeColSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutOne(objectId, caseTypeColSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Col Sets  Put Some
         * @param {Array<CaseTypeColSet>} caseTypeColSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColSetsPutSome(caseTypeColSet: Array<CaseTypeColSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeColSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColSetsPutSome(caseTypeColSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Post One
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostOne(caseTypeCol: CaseTypeCol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostOne(caseTypeCol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Post Some
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPostSome(caseTypeCol: Array<CaseTypeCol>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPostSome(caseTypeCol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Put One
         * @param {string} objectId 
         * @param {CaseTypeCol} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPutOne(objectId: string, caseTypeCol: CaseTypeCol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeCol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPutOne(objectId, caseTypeCol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Cols  Put Some
         * @param {Array<CaseTypeCol>} caseTypeCol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeColsPutSome(caseTypeCol: Array<CaseTypeCol>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeCol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeColsPutSome(caseTypeCol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeColsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeDim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeDim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeDim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Post One
         * @param {CaseTypeDim} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPostOne(caseTypeDim: CaseTypeDim, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeDim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPostOne(caseTypeDim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeDim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Post Some
         * @param {Array<CaseTypeDim>} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPostSome(caseTypeDim: Array<CaseTypeDim>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeDim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPostSome(caseTypeDim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Put One
         * @param {string} objectId 
         * @param {CaseTypeDim} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPutOne(objectId: string, caseTypeDim: CaseTypeDim, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeDim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPutOne(objectId, caseTypeDim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Dims  Put Some
         * @param {Array<CaseTypeDim>} caseTypeDim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeDimsPutSome(caseTypeDim: Array<CaseTypeDim>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeDim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeDimsPutSome(caseTypeDim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeDimsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Post One
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostOne(caseTypeSetCategory: CaseTypeSetCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostOne(caseTypeSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Post Some
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPostSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPostSome(caseTypeSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Put One
         * @param {string} objectId 
         * @param {CaseTypeSetCategory} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPutOne(objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPutOne(objectId, caseTypeSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Categories  Put Some
         * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetCategoriesPutSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetCategoriesPutSome(caseTypeSetCategory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetCategoriesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Post One
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostOne(caseTypeSetMember: CaseTypeSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostOne(caseTypeSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Post Some
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPostSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPostSome(caseTypeSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Put One
         * @param {string} objectId 
         * @param {CaseTypeSetMember} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPutOne(objectId: string, caseTypeSetMember: CaseTypeSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPutOne(objectId, caseTypeSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Set Members  Put Some
         * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetMembersPutSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetMembersPutSome(caseTypeSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetMembersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Post One
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostOne(caseTypeSet: CaseTypeSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostOne(caseTypeSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Post Some
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPostSome(caseTypeSet: Array<CaseTypeSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPostSome(caseTypeSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Association Between Casetypeset And Casetype
         * @param {string} caseTypeSetId 
         * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutCaseTypes(caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutCaseTypes(caseTypeSetId, updateCaseTypeSetCaseTypesRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPutCaseTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Put One
         * @param {string} objectId 
         * @param {CaseTypeSet} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutOne(objectId: string, caseTypeSet: CaseTypeSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseTypeSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutOne(objectId, caseTypeSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Type Sets  Put Some
         * @param {Array<CaseTypeSet>} caseTypeSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypeSetsPutSome(caseTypeSet: Array<CaseTypeSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseTypeSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypeSetsPutSome(caseTypeSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypeSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Post One
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostOne(caseType: CaseType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostOne(caseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Post Some
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPostSome(caseType: Array<CaseType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPostSome(caseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Put One
         * @param {string} objectId 
         * @param {CaseType} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPutOne(objectId: string, caseType: CaseType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPutOne(objectId, caseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Case Types  Put Some
         * @param {Array<CaseType>} caseType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async caseTypesPutSome(caseType: Array<CaseType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.caseTypesPutSome(caseType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.caseTypesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Post One
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostOne(_case: Case, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostOne(_case, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Post Some
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPostSome(_case: Array<Case>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPostSome(_case, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Put One
         * @param {string} objectId 
         * @param {Case} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPutOne(objectId: string, _case: Case, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Case>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPutOne(objectId, _case, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cases  Put Some
         * @param {Array<Case>} _case 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async casesPutSome(_case: Array<Case>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casesPutSome(_case, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.casesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Post One
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostOne(col: Col, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostOne(col, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Post Some
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPostSome(col: Array<Col>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPostSome(col, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Put One
         * @param {string} objectId 
         * @param {Col} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPutOne(objectId: string, col: Col, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Col>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPutOne(objectId, col, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cols  Put Some
         * @param {Array<Col>} col 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsPutSome(col: Array<Col>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Col>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsPutSome(col, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The additional validation rules that a Col instance must comply with.
         * @summary Col Validation Rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async colsValidationRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ColValidationRulesResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.colsValidationRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.colsValidationRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a complete case type.
         * @summary Retrieve Complete Case Type
         * @param {string} caseTypeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeCaseTypesGetOne(caseTypeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompleteCaseType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeCaseTypesGetOne(caseTypeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.completeCaseTypesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new case set and associate it with the specified data collections and cases.
         * @summary Create Case Set
         * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCaseSet(createCaseSetRequestBody: CreateCaseSetRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCaseSet(createCaseSetRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.createCaseSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a file for a read set associated with a case.
         * @summary Create File For Reads Set
         * @param {string} caseId 
         * @param {string} caseTypeColId 
         * @param {CreateFileForReadSetRequestBody} createFileForReadSetRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileForReadSet(caseId: string, caseTypeColId: string, createFileForReadSetRequestBody: CreateFileForReadSetRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileForReadSet(caseId, caseTypeColId, createFileForReadSetRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.createFileForReadSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a file for a sequence associated with a case.
         * @summary Create File For Sequence
         * @param {string} caseId 
         * @param {string} caseTypeColId 
         * @param {CreateFileForSeqRequestBody} createFileForSeqRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFileForSeq(caseId: string, caseTypeColId: string, createFileForSeqRequestBody: CreateFileForSeqRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFileForSeq(caseId, caseTypeColId, createFileForSeqRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.createFileForSeq']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Post One
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostOne(dim: Dim, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostOne(dim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Post Some
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPostSome(dim: Array<Dim>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPostSome(dim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Put One
         * @param {string} objectId 
         * @param {Dim} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPutOne(objectId: string, dim: Dim, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dim>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPutOne(objectId, dim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Dims  Put Some
         * @param {Array<Dim>} dim 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dimsPutSome(dim: Array<Dim>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dim>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dimsPutSome(dim, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.dimsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post One
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostOne(geneticDistanceProtocol: GeneticDistanceProtocol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostOne(geneticDistanceProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Post Some
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPostSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPostSome(geneticDistanceProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Put One
         * @param {string} objectId 
         * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPutOne(objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneticDistanceProtocol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPutOne(objectId, geneticDistanceProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Genetic Distance Protocols  Put Some
         * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geneticDistanceProtocolsPutSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticDistanceProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geneticDistanceProtocolsPutSome(geneticDistanceProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.geneticDistanceProtocolsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve assembly protocols from seqdb database
         * @summary Retrieve Assembly Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAssemblyProtocols(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AssemblyProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAssemblyProtocols(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveAssemblyProtocols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases based on a query.
         * @summary Retrieve Case Ids By Query
         * @param {CaseQuery} caseQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseIdsByQuery(caseQuery: CaseQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseIdsByQuery(caseQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCaseIdsByQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve access rights for a set of cases.
         * @summary Retrieve Case Rights
         * @param {RetrieveCaseRightsRequestBody} retrieveCaseRightsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseRights(retrieveCaseRightsRequestBody: RetrieveCaseRightsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseRights>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseRights(retrieveCaseRightsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCaseRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve access rights for a set of case sets.
         * @summary Retrieve Case Set Rights
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseSetRights(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseSetRights>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseSetRights(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCaseSetRights']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
         * @summary Retrieve Case Set Statistics
         * @param {RetrieveCaseSetStatsRequestBody} retrieveCaseSetStatsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseSetStats(retrieveCaseSetStatsRequestBody: RetrieveCaseSetStatsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseSetStats(retrieveCaseSetStatsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCaseSetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
         * @summary Retrieve Case Type Statistics
         * @param {RetrieveCaseTypeStatsRequestBody} retrieveCaseTypeStatsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCaseTypeStats(retrieveCaseTypeStatsRequestBody: RetrieveCaseTypeStatsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CaseStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCaseTypeStats(retrieveCaseTypeStatsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCaseTypeStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve cases by their IDs.
         * @summary Retrieve Cases By Ids
         * @param {RetrieveCasesByIdsRequestBody} retrieveCasesByIdsRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCasesByIds(retrieveCasesByIdsRequestBody: RetrieveCasesByIdsRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Case>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCasesByIds(retrieveCasesByIdsRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveCasesByIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a set of genetic sequences based on a set of case IDs and a genetic sequence case type column.
         * @summary Retrieve Genetic Sequence By Case
         * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGeneticSequence(retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneticSequence>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGeneticSequence(retrieveGeneticSequenceRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveGeneticSequence']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a set of genetic sequences in FASTA format based on a set of case IDs and a genetic sequence case type column. An iterator is returned that yields the FASTA lines.
         * @summary Retrieve Genetic Sequence By Case, In Fasta Format And Streamed
         * @param {string} token 
         * @param {string} caseTypeId 
         * @param {string} geneticSequenceCaseTypeColId 
         * @param {Array<string>} caseIds 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGeneticSequenceFasta(token: string, caseTypeId: string, geneticSequenceCaseTypeColId: string, caseIds: Array<string>, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGeneticSequenceFasta(token, caseTypeId, geneticSequenceCaseTypeColId, caseIds, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveGeneticSequenceFasta']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves Contacts associated with organizations, sites, or specific contacts.  Exactly one of organization_ids, site_ids, or contact_ids must be provided. Returns a list of contacts with their associated site and organization data cascaded.
         * @summary Retrieve Organization Contact
         * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOrganizationContact(retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOrganizationContact(retrieveOrganizationContactRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveOrganizationContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a phylogenetic tree based on a set of case IDs, a tree algorithm, and a genetic distance case type column.
         * @summary Retrieve Phylogenetic Tree
         * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhylogeneticTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrievePhylogeneticTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve sequencing protocols from seqdb database
         * @summary Retrieve Sequencing Protocols
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSequencingProtocols(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SequencingProtocol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSequencingProtocols(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.retrieveSequencingProtocols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post One
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostOne(treeAlgorithmClass: TreeAlgorithmClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostOne(treeAlgorithmClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Post Some
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPostSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPostSome(treeAlgorithmClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Put One
         * @param {string} objectId 
         * @param {TreeAlgorithmClass} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPutOne(objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithmClass>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPutOne(objectId, treeAlgorithmClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithm Classes  Put Some
         * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmClassesPutSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithmClass>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmClassesPutSome(treeAlgorithmClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmClassesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Post One
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostOne(treeAlgorithm: TreeAlgorithm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostOne(treeAlgorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Post Some
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPostSome(treeAlgorithm: Array<TreeAlgorithm>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPostSome(treeAlgorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Put One
         * @param {string} objectId 
         * @param {TreeAlgorithm} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPutOne(objectId: string, treeAlgorithm: TreeAlgorithm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeAlgorithm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPutOne(objectId, treeAlgorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Tree Algorithms  Put Some
         * @param {Array<TreeAlgorithm>} treeAlgorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async treeAlgorithmsPutSome(treeAlgorithm: Array<TreeAlgorithm>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeAlgorithm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.treeAlgorithmsPutSome(treeAlgorithm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.treeAlgorithmsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a batch of cases along with their associated data and return an upload result. The upload can be stopped after the verification step by setting the \'verify_only\' property to True, so that the returned upload result only contains the verification results.  The data are uploaded as a single atomic unit of work, so that either all data are successfully uploaded or none are.
         * @summary Upload Cases
         * @param {UploadCasesCommand} uploadCasesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCases(uploadCasesCommand: UploadCasesCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CaseBatchUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCases(uploadCasesCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CaseApi.uploadCases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CaseApi - factory interface
 * @export
 */

/**
 * CaseApi - object-oriented interface

 * @export
 * @class CaseApi
 * @extends {BaseAPI}
 */
export class CaseApi extends BaseAPI {
  private static __instance: CaseApi;
  public static get instance(): CaseApi {
    CaseApi.__instance = CaseApi.__instance || new CaseApi();
    return CaseApi.__instance;
  }

    /**
     * 
     * @summary Case Data Collection Links  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Post One
     * @param {CaseDataCollectionLink} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostOne(caseDataCollectionLink: CaseDataCollectionLink, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostOne(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Post Some
     * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPostSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPostSome(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Put One
     * @param {string} objectId 
     * @param {CaseDataCollectionLink} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPutOne(objectId: string, caseDataCollectionLink: CaseDataCollectionLink, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPutOne(objectId, caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Data Collection Links  Put Some
     * @param {Array<CaseDataCollectionLink>} caseDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseDataCollectionLinksPutSome(caseDataCollectionLink: Array<CaseDataCollectionLink>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseDataCollectionLinksPutSome(caseDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Post One
     * @param {CaseSetCategory} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostOne(caseSetCategory: CaseSetCategory, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostOne(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Post Some
     * @param {Array<CaseSetCategory>} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPostSome(caseSetCategory: Array<CaseSetCategory>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPostSome(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Put One
     * @param {string} objectId 
     * @param {CaseSetCategory} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPutOne(objectId: string, caseSetCategory: CaseSetCategory, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPutOne(objectId, caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Categories  Put Some
     * @param {Array<CaseSetCategory>} caseSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetCategoriesPutSome(caseSetCategory: Array<CaseSetCategory>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetCategoriesPutSome(caseSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Post One
     * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostOne(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Post Some
     * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPostSome(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Put One
     * @param {string} objectId 
     * @param {CaseSetDataCollectionLink} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPutOne(objectId: string, caseSetDataCollectionLink: CaseSetDataCollectionLink, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPutOne(objectId, caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Data Collection Links  Put Some
     * @param {Array<CaseSetDataCollectionLink>} caseSetDataCollectionLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink: Array<CaseSetDataCollectionLink>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetDataCollectionLinksPutSome(caseSetDataCollectionLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Post One
     * @param {CaseSetMember} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostOne(caseSetMember: CaseSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostOne(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Post Some
     * @param {Array<CaseSetMember>} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPostSome(caseSetMember: Array<CaseSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPostSome(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Put One
     * @param {string} objectId 
     * @param {CaseSetMember} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPutOne(objectId: string, caseSetMember: CaseSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPutOne(objectId, caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Members  Put Some
     * @param {Array<CaseSetMember>} caseSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetMembersPutSome(caseSetMember: Array<CaseSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetMembersPutSome(caseSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Post One
     * @param {CaseSetStatus} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostOne(caseSetStatus: CaseSetStatus, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostOne(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Post Some
     * @param {Array<CaseSetStatus>} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPostSome(caseSetStatus: Array<CaseSetStatus>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPostSome(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Put One
     * @param {string} objectId 
     * @param {CaseSetStatus} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPutOne(objectId: string, caseSetStatus: CaseSetStatus, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPutOne(objectId, caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Set Statuses  Put Some
     * @param {Array<CaseSetStatus>} caseSetStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetStatusesPutSome(caseSetStatus: Array<CaseSetStatus>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetStatusesPutSome(caseSetStatus, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Post One
     * @param {CaseSet} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostOne(caseSet: CaseSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostOne(caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Post Some
     * @param {Array<CaseSet>} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPostSome(caseSet: Array<CaseSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPostSome(caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Put One
     * @param {string} objectId 
     * @param {CaseSet} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPutOne(objectId: string, caseSet: CaseSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPutOne(objectId, caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Sets  Put Some
     * @param {Array<CaseSet>} caseSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseSetsPutSome(caseSet: Array<CaseSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseSetsPutSome(caseSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Post One
     * @param {CaseTypeColSetMember} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostOne(caseTypeColSetMember: CaseTypeColSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostOne(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Post Some
     * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPostSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPostSome(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Put One
     * @param {string} objectId 
     * @param {CaseTypeColSetMember} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPutOne(objectId: string, caseTypeColSetMember: CaseTypeColSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPutOne(objectId, caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Set Members  Put Some
     * @param {Array<CaseTypeColSetMember>} caseTypeColSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetMembersPutSome(caseTypeColSetMember: Array<CaseTypeColSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetMembersPutSome(caseTypeColSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Post One
     * @param {CaseTypeColSet} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostOne(caseTypeColSet: CaseTypeColSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostOne(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Post Some
     * @param {Array<CaseTypeColSet>} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPostSome(caseTypeColSet: Array<CaseTypeColSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPostSome(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Update Association Between Casetypecolset And Casetypecol
     * @param {string} caseTypeColSetId 
     * @param {UpdateCaseTypeColSetCaseTypeColsRequestBody} updateCaseTypeColSetCaseTypeColsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutCaseTypeCols(caseTypeColSetId: string, updateCaseTypeColSetCaseTypeColsRequestBody: UpdateCaseTypeColSetCaseTypeColsRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutCaseTypeCols(caseTypeColSetId, updateCaseTypeColSetCaseTypeColsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Put One
     * @param {string} objectId 
     * @param {CaseTypeColSet} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutOne(objectId: string, caseTypeColSet: CaseTypeColSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutOne(objectId, caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Col Sets  Put Some
     * @param {Array<CaseTypeColSet>} caseTypeColSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColSetsPutSome(caseTypeColSet: Array<CaseTypeColSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColSetsPutSome(caseTypeColSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Post One
     * @param {CaseTypeCol} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostOne(caseTypeCol: CaseTypeCol, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostOne(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Post Some
     * @param {Array<CaseTypeCol>} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPostSome(caseTypeCol: Array<CaseTypeCol>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPostSome(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Put One
     * @param {string} objectId 
     * @param {CaseTypeCol} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPutOne(objectId: string, caseTypeCol: CaseTypeCol, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPutOne(objectId, caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Cols  Put Some
     * @param {Array<CaseTypeCol>} caseTypeCol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeColsPutSome(caseTypeCol: Array<CaseTypeCol>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeColsPutSome(caseTypeCol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Post One
     * @param {CaseTypeDim} caseTypeDim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPostOne(caseTypeDim: CaseTypeDim, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPostOne(caseTypeDim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Post Some
     * @param {Array<CaseTypeDim>} caseTypeDim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPostSome(caseTypeDim: Array<CaseTypeDim>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPostSome(caseTypeDim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Put One
     * @param {string} objectId 
     * @param {CaseTypeDim} caseTypeDim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPutOne(objectId: string, caseTypeDim: CaseTypeDim, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPutOne(objectId, caseTypeDim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Dims  Put Some
     * @param {Array<CaseTypeDim>} caseTypeDim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeDimsPutSome(caseTypeDim: Array<CaseTypeDim>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeDimsPutSome(caseTypeDim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Post One
     * @param {CaseTypeSetCategory} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostOne(caseTypeSetCategory: CaseTypeSetCategory, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostOne(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Post Some
     * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPostSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPostSome(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Put One
     * @param {string} objectId 
     * @param {CaseTypeSetCategory} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPutOne(objectId: string, caseTypeSetCategory: CaseTypeSetCategory, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPutOne(objectId, caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Categories  Put Some
     * @param {Array<CaseTypeSetCategory>} caseTypeSetCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetCategoriesPutSome(caseTypeSetCategory: Array<CaseTypeSetCategory>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetCategoriesPutSome(caseTypeSetCategory, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Post One
     * @param {CaseTypeSetMember} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostOne(caseTypeSetMember: CaseTypeSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostOne(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Post Some
     * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPostSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPostSome(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Put One
     * @param {string} objectId 
     * @param {CaseTypeSetMember} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPutOne(objectId: string, caseTypeSetMember: CaseTypeSetMember, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPutOne(objectId, caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Set Members  Put Some
     * @param {Array<CaseTypeSetMember>} caseTypeSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetMembersPutSome(caseTypeSetMember: Array<CaseTypeSetMember>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetMembersPutSome(caseTypeSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Post One
     * @param {CaseTypeSet} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostOne(caseTypeSet: CaseTypeSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostOne(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Post Some
     * @param {Array<CaseTypeSet>} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPostSome(caseTypeSet: Array<CaseTypeSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPostSome(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Update Association Between Casetypeset And Casetype
     * @param {string} caseTypeSetId 
     * @param {UpdateCaseTypeSetCaseTypesRequestBody} updateCaseTypeSetCaseTypesRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutCaseTypes(caseTypeSetId: string, updateCaseTypeSetCaseTypesRequestBody: UpdateCaseTypeSetCaseTypesRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutCaseTypes(caseTypeSetId, updateCaseTypeSetCaseTypesRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Put One
     * @param {string} objectId 
     * @param {CaseTypeSet} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutOne(objectId: string, caseTypeSet: CaseTypeSet, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutOne(objectId, caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Type Sets  Put Some
     * @param {Array<CaseTypeSet>} caseTypeSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypeSetsPutSome(caseTypeSet: Array<CaseTypeSet>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypeSetsPutSome(caseTypeSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Post One
     * @param {CaseType} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostOne(caseType: CaseType, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostOne(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Post Some
     * @param {Array<CaseType>} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPostSome(caseType: Array<CaseType>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPostSome(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Put One
     * @param {string} objectId 
     * @param {CaseType} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPutOne(objectId: string, caseType: CaseType, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPutOne(objectId, caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Case Types  Put Some
     * @param {Array<CaseType>} caseType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public caseTypesPutSome(caseType: Array<CaseType>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).caseTypesPutSome(caseType, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Post One
     * @param {Case} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostOne(_case: Case, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostOne(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Post Some
     * @param {Array<Case>} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPostSome(_case: Array<Case>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPostSome(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Put One
     * @param {string} objectId 
     * @param {Case} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPutOne(objectId: string, _case: Case, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPutOne(objectId, _case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cases  Put Some
     * @param {Array<Case>} _case 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public casesPutSome(_case: Array<Case>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).casesPutSome(_case, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Post One
     * @param {Col} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostOne(col: Col, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostOne(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Post Some
     * @param {Array<Col>} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPostSome(col: Array<Col>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPostSome(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Put One
     * @param {string} objectId 
     * @param {Col} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPutOne(objectId: string, col: Col, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPutOne(objectId, col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Cols  Put Some
     * @param {Array<Col>} col 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsPutSome(col: Array<Col>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsPutSome(col, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * The additional validation rules that a Col instance must comply with.
     * @summary Col Validation Rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public colsValidationRules(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).colsValidationRules(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve a complete case type.
     * @summary Retrieve Complete Case Type
     * @param {string} caseTypeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public completeCaseTypesGetOne(caseTypeId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).completeCaseTypesGetOne(caseTypeId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Create a new case set and associate it with the specified data collections and cases.
     * @summary Create Case Set
     * @param {CreateCaseSetRequestBody} createCaseSetRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public createCaseSet(createCaseSetRequestBody: CreateCaseSetRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).createCaseSet(createCaseSetRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Create a file for a read set associated with a case.
     * @summary Create File For Reads Set
     * @param {string} caseId 
     * @param {string} caseTypeColId 
     * @param {CreateFileForReadSetRequestBody} createFileForReadSetRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public createFileForReadSet(caseId: string, caseTypeColId: string, createFileForReadSetRequestBody: CreateFileForReadSetRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).createFileForReadSet(caseId, caseTypeColId, createFileForReadSetRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Create a file for a sequence associated with a case.
     * @summary Create File For Sequence
     * @param {string} caseId 
     * @param {string} caseTypeColId 
     * @param {CreateFileForSeqRequestBody} createFileForSeqRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public createFileForSeq(caseId: string, caseTypeColId: string, createFileForSeqRequestBody: CreateFileForSeqRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).createFileForSeq(caseId, caseTypeColId, createFileForSeqRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Post One
     * @param {Dim} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostOne(dim: Dim, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostOne(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Post Some
     * @param {Array<Dim>} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPostSome(dim: Array<Dim>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPostSome(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Put One
     * @param {string} objectId 
     * @param {Dim} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPutOne(objectId: string, dim: Dim, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPutOne(objectId, dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Dims  Put Some
     * @param {Array<Dim>} dim 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public dimsPutSome(dim: Array<Dim>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).dimsPutSome(dim, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Post One
     * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostOne(geneticDistanceProtocol: GeneticDistanceProtocol, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostOne(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Post Some
     * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPostSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPostSome(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Put One
     * @param {string} objectId 
     * @param {GeneticDistanceProtocol} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPutOne(objectId: string, geneticDistanceProtocol: GeneticDistanceProtocol, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPutOne(objectId, geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Genetic Distance Protocols  Put Some
     * @param {Array<GeneticDistanceProtocol>} geneticDistanceProtocol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public geneticDistanceProtocolsPutSome(geneticDistanceProtocol: Array<GeneticDistanceProtocol>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).geneticDistanceProtocolsPutSome(geneticDistanceProtocol, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve assembly protocols from seqdb database
     * @summary Retrieve Assembly Protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveAssemblyProtocols(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveAssemblyProtocols(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve cases based on a query.
     * @summary Retrieve Case Ids By Query
     * @param {CaseQuery} caseQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseIdsByQuery(caseQuery: CaseQuery, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseIdsByQuery(caseQuery, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve access rights for a set of cases.
     * @summary Retrieve Case Rights
     * @param {RetrieveCaseRightsRequestBody} retrieveCaseRightsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseRights(retrieveCaseRightsRequestBody: RetrieveCaseRightsRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseRights(retrieveCaseRightsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve access rights for a set of case sets.
     * @summary Retrieve Case Set Rights
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseSetRights(requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseSetRights(requestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
     * @summary Retrieve Case Set Statistics
     * @param {RetrieveCaseSetStatsRequestBody} retrieveCaseSetStatsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseSetStats(retrieveCaseSetStatsRequestBody: RetrieveCaseSetStatsRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseSetStats(retrieveCaseSetStatsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve statistics for a set of case types. Each of the parameters, when provided, will further filter the cases that are considered for the statistics.
     * @summary Retrieve Case Type Statistics
     * @param {RetrieveCaseTypeStatsRequestBody} retrieveCaseTypeStatsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCaseTypeStats(retrieveCaseTypeStatsRequestBody: RetrieveCaseTypeStatsRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCaseTypeStats(retrieveCaseTypeStatsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve cases by their IDs.
     * @summary Retrieve Cases By Ids
     * @param {RetrieveCasesByIdsRequestBody} retrieveCasesByIdsRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveCasesByIds(retrieveCasesByIdsRequestBody: RetrieveCasesByIdsRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveCasesByIds(retrieveCasesByIdsRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve a set of genetic sequences based on a set of case IDs and a genetic sequence case type column.
     * @summary Retrieve Genetic Sequence By Case
     * @param {RetrieveGeneticSequenceRequestBody} retrieveGeneticSequenceRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveGeneticSequence(retrieveGeneticSequenceRequestBody: RetrieveGeneticSequenceRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveGeneticSequence(retrieveGeneticSequenceRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve a set of genetic sequences in FASTA format based on a set of case IDs and a genetic sequence case type column. An iterator is returned that yields the FASTA lines.
     * @summary Retrieve Genetic Sequence By Case, In Fasta Format And Streamed
     * @param {string} token 
     * @param {string} caseTypeId 
     * @param {string} geneticSequenceCaseTypeColId 
     * @param {Array<string>} caseIds 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveGeneticSequenceFasta(token: string, caseTypeId: string, geneticSequenceCaseTypeColId: string, caseIds: Array<string>, fileName: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveGeneticSequenceFasta(token, caseTypeId, geneticSequenceCaseTypeColId, caseIds, fileName, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieves Contacts associated with organizations, sites, or specific contacts.  Exactly one of organization_ids, site_ids, or contact_ids must be provided. Returns a list of contacts with their associated site and organization data cascaded.
     * @summary Retrieve Organization Contact
     * @param {RetrieveOrganizationContactRequestBody} retrieveOrganizationContactRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveOrganizationContact(retrieveOrganizationContactRequestBody: RetrieveOrganizationContactRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveOrganizationContact(retrieveOrganizationContactRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve a phylogenetic tree based on a set of case IDs, a tree algorithm, and a genetic distance case type column.
     * @summary Retrieve Phylogenetic Tree
     * @param {RetrievePhylogeneticTreeRequestBody} retrievePhylogeneticTreeRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody: RetrievePhylogeneticTreeRequestBody, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrievePhylogeneticTree(retrievePhylogeneticTreeRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieve sequencing protocols from seqdb database
     * @summary Retrieve Sequencing Protocols
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public retrieveSequencingProtocols(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).retrieveSequencingProtocols(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Post One
     * @param {TreeAlgorithmClass} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostOne(treeAlgorithmClass: TreeAlgorithmClass, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostOne(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Post Some
     * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPostSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPostSome(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Put One
     * @param {string} objectId 
     * @param {TreeAlgorithmClass} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPutOne(objectId: string, treeAlgorithmClass: TreeAlgorithmClass, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPutOne(objectId, treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithm Classes  Put Some
     * @param {Array<TreeAlgorithmClass>} treeAlgorithmClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmClassesPutSome(treeAlgorithmClass: Array<TreeAlgorithmClass>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmClassesPutSome(treeAlgorithmClass, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetAll(options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Post One
     * @param {TreeAlgorithm} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostOne(treeAlgorithm: TreeAlgorithm, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostOne(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Post Some
     * @param {Array<TreeAlgorithm>} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPostSome(treeAlgorithm: Array<TreeAlgorithm>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPostSome(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Put One
     * @param {string} objectId 
     * @param {TreeAlgorithm} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPutOne(objectId: string, treeAlgorithm: TreeAlgorithm, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPutOne(objectId, treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Tree Algorithms  Put Some
     * @param {Array<TreeAlgorithm>} treeAlgorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public treeAlgorithmsPutSome(treeAlgorithm: Array<TreeAlgorithm>, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).treeAlgorithmsPutSome(treeAlgorithm, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Upload a batch of cases along with their associated data and return an upload result. The upload can be stopped after the verification step by setting the \'verify_only\' property to True, so that the returned upload result only contains the verification results.  The data are uploaded as a single atomic unit of work, so that either all data are successfully uploaded or none are.
     * @summary Upload Cases
     * @param {UploadCasesCommand} uploadCasesCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CaseApi
     */
    public uploadCases(uploadCasesCommand: UploadCasesCommand, options?: RawAxiosRequestConfig) {
        return CaseApiFp(this.configuration).uploadCases(uploadCasesCommand, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Redirect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.redirectGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */

/**
 * DefaultApi - object-oriented interface

 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  private static __instance: DefaultApi;
  public static get instance(): DefaultApi {
    DefaultApi.__instance = DefaultApi.__instance || new DefaultApi();
    return DefaultApi.__instance;
  }

    /**
     * 
     * @summary Redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public redirectGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).redirectGet(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * GeoApi - axios parameter creator
 * @export
 */
const GeoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Region Relations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionRelationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionRelationsGetSome', 'ids', ids)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Post One
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostOne: async (regionRelation: RegionRelation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPostOne', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionRelationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_relations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionRelationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_relations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Post Some
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPostSome: async (regionRelation: Array<RegionRelation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPostSome', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Put One
         * @param {string} objectId 
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPutOne: async (objectId: string, regionRelation: RegionRelation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionRelationsPutOne', 'objectId', objectId)
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPutOne', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Relations  Put Some
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionRelationsPutSome: async (regionRelation: Array<RegionRelation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionRelation' is not null or undefined
            assertParamExists('regionRelationsPutSome', 'regionRelation', regionRelation)
            const localVarPath = `/v1/region_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetShapesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetShapesGetSome', 'ids', ids)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Post One
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostOne: async (regionSetShape: RegionSetShape, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPostOne', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetShapesPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_set_shapes/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetShapesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_set_shapes/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Post Some
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPostSome: async (regionSetShape: Array<RegionSetShape>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPostSome', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Put One
         * @param {string} objectId 
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPutOne: async (objectId: string, regionSetShape: RegionSetShape, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetShapesPutOne', 'objectId', objectId)
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPutOne', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Set Shapes  Put Some
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetShapesPutSome: async (regionSetShape: Array<RegionSetShape>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSetShape' is not null or undefined
            assertParamExists('regionSetShapesPutSome', 'regionSetShape', regionSetShape)
            const localVarPath = `/v1/region_set_shapes/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSetShape, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Post One
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostOne: async (regionSet: RegionSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPostOne', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/region_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/region_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Post Some
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPostSome: async (regionSet: Array<RegionSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPostSome', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Put One
         * @param {string} objectId 
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPutOne: async (objectId: string, regionSet: RegionSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionSetsPutOne', 'objectId', objectId)
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPutOne', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Region Sets  Put Some
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionSetsPutSome: async (regionSet: Array<RegionSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionSet' is not null or undefined
            assertParamExists('regionSetsPutSome', 'regionSet', regionSet)
            const localVarPath = `/v1/region_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('regionsGetSome', 'ids', ids)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Post One
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostOne: async (region: Region, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPostOne', 'region', region)
            const localVarPath = `/v1/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionsPostQuery', 'filter', filter)
            const localVarPath = `/v1/regions/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('regionsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/regions/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Post Some
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPostSome: async (region: Array<Region>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPostSome', 'region', region)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Put One
         * @param {string} objectId 
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPutOne: async (objectId: string, region: Region, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('regionsPutOne', 'objectId', objectId)
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPutOne', 'region', region)
            const localVarPath = `/v1/regions/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regions  Put Some
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPutSome: async (region: Array<Region>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('regionsPutSome', 'region', region)
            const localVarPath = `/v1/regions/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoApi - functional programming interface
 * @export
 */
const GeoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Region Relations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Post One
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostOne(regionRelation: RegionRelation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostOne(regionRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Post Some
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPostSome(regionRelation: Array<RegionRelation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPostSome(regionRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Put One
         * @param {string} objectId 
         * @param {RegionRelation} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPutOne(objectId: string, regionRelation: RegionRelation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPutOne(objectId, regionRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Relations  Put Some
         * @param {Array<RegionRelation>} regionRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionRelationsPutSome(regionRelation: Array<RegionRelation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionRelationsPutSome(regionRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionRelationsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Post One
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostOne(regionSetShape: RegionSetShape, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostOne(regionSetShape, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Post Some
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPostSome(regionSetShape: Array<RegionSetShape>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPostSome(regionSetShape, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Put One
         * @param {string} objectId 
         * @param {RegionSetShape} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPutOne(objectId: string, regionSetShape: RegionSetShape, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSetShape>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPutOne(objectId, regionSetShape, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Set Shapes  Put Some
         * @param {Array<RegionSetShape>} regionSetShape 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetShapesPutSome(regionSetShape: Array<RegionSetShape>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSetShape>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetShapesPutSome(regionSetShape, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetShapesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Post One
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostOne(regionSet: RegionSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostOne(regionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Post Some
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPostSome(regionSet: Array<RegionSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPostSome(regionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Put One
         * @param {string} objectId 
         * @param {RegionSet} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPutOne(objectId: string, regionSet: RegionSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPutOne(objectId, regionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Region Sets  Put Some
         * @param {Array<RegionSet>} regionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionSetsPutSome(regionSet: Array<RegionSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionSetsPutSome(regionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Post One
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostOne(region: Region, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostOne(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Post Some
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPostSome(region: Array<Region>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPostSome(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Put One
         * @param {string} objectId 
         * @param {Region} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPutOne(objectId: string, region: Region, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPutOne(objectId, region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regions  Put Some
         * @param {Array<Region>} region 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPutSome(region: Array<Region>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Region>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPutSome(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoApi.regionsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeoApi - factory interface
 * @export
 */

/**
 * GeoApi - object-oriented interface

 * @export
 * @class GeoApi
 * @extends {BaseAPI}
 */
export class GeoApi extends BaseAPI {
  private static __instance: GeoApi;
  public static get instance(): GeoApi {
    GeoApi.__instance = GeoApi.__instance || new GeoApi();
    return GeoApi.__instance;
  }

    /**
     * 
     * @summary Region Relations  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Post One
     * @param {RegionRelation} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostOne(regionRelation: RegionRelation, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostOne(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Post Some
     * @param {Array<RegionRelation>} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPostSome(regionRelation: Array<RegionRelation>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPostSome(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Put One
     * @param {string} objectId 
     * @param {RegionRelation} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPutOne(objectId: string, regionRelation: RegionRelation, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPutOne(objectId, regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Relations  Put Some
     * @param {Array<RegionRelation>} regionRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionRelationsPutSome(regionRelation: Array<RegionRelation>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionRelationsPutSome(regionRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Post One
     * @param {RegionSetShape} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostOne(regionSetShape: RegionSetShape, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostOne(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Post Some
     * @param {Array<RegionSetShape>} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPostSome(regionSetShape: Array<RegionSetShape>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPostSome(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Put One
     * @param {string} objectId 
     * @param {RegionSetShape} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPutOne(objectId: string, regionSetShape: RegionSetShape, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPutOne(objectId, regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Set Shapes  Put Some
     * @param {Array<RegionSetShape>} regionSetShape 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetShapesPutSome(regionSetShape: Array<RegionSetShape>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetShapesPutSome(regionSetShape, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Post One
     * @param {RegionSet} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostOne(regionSet: RegionSet, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostOne(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Post Some
     * @param {Array<RegionSet>} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPostSome(regionSet: Array<RegionSet>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPostSome(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Put One
     * @param {string} objectId 
     * @param {RegionSet} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPutOne(objectId: string, regionSet: RegionSet, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPutOne(objectId, regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Region Sets  Put Some
     * @param {Array<RegionSet>} regionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionSetsPutSome(regionSet: Array<RegionSet>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionSetsPutSome(regionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetAll(options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Post One
     * @param {Region} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostOne(region: Region, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostOne(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Post Some
     * @param {Array<Region>} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPostSome(region: Array<Region>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPostSome(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Put One
     * @param {string} objectId 
     * @param {Region} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPutOne(objectId: string, region: Region, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPutOne(objectId, region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Regions  Put Some
     * @param {Array<Region>} region 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoApi
     */
    public regionsPutSome(region: Array<Region>, options?: RawAxiosRequestConfig) {
        return GeoApiFp(this.configuration).regionsPutSome(region, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * OntologyApi - axios parameter creator
 * @export
 */
const OntologyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Concept Relations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptRelationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptRelationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concept_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptRelationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptRelationsGetSome', 'ids', ids)
            const localVarPath = `/v1/concept_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Post One
         * @param {ConceptRelation} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPostOne: async (conceptRelation: ConceptRelation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptRelation' is not null or undefined
            assertParamExists('conceptRelationsPostOne', 'conceptRelation', conceptRelation)
            const localVarPath = `/v1/concept_relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptRelationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/concept_relations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptRelationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concept_relations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Post Some
         * @param {Array<ConceptRelation>} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPostSome: async (conceptRelation: Array<ConceptRelation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptRelation' is not null or undefined
            assertParamExists('conceptRelationsPostSome', 'conceptRelation', conceptRelation)
            const localVarPath = `/v1/concept_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Put One
         * @param {string} objectId 
         * @param {ConceptRelation} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPutOne: async (objectId: string, conceptRelation: ConceptRelation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptRelationsPutOne', 'objectId', objectId)
            // verify required parameter 'conceptRelation' is not null or undefined
            assertParamExists('conceptRelationsPutOne', 'conceptRelation', conceptRelation)
            const localVarPath = `/v1/concept_relations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Relations  Put Some
         * @param {Array<ConceptRelation>} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptRelationsPutSome: async (conceptRelation: Array<ConceptRelation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptRelation' is not null or undefined
            assertParamExists('conceptRelationsPutSome', 'conceptRelation', conceptRelation)
            const localVarPath = `/v1/concept_relations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Post One
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostOne: async (conceptSet: ConceptSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPostOne', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/concept_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concept_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Post Some
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPostSome: async (conceptSet: Array<ConceptSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPostSome', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Put One
         * @param {string} objectId 
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPutOne: async (objectId: string, conceptSet: ConceptSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptSetsPutOne', 'objectId', objectId)
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPutOne', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concept Sets  Put Some
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptSetsPutSome: async (conceptSet: Array<ConceptSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conceptSet' is not null or undefined
            assertParamExists('conceptSetsPutSome', 'conceptSet', conceptSet)
            const localVarPath = `/v1/concept_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conceptSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('conceptsGetSome', 'ids', ids)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Post One
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostOne: async (concept: Concept, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPostOne', 'concept', concept)
            const localVarPath = `/v1/concepts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptsPostQuery', 'filter', filter)
            const localVarPath = `/v1/concepts/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('conceptsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/concepts/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Post Some
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPostSome: async (concept: Array<Concept>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPostSome', 'concept', concept)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Put One
         * @param {string} objectId 
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPutOne: async (objectId: string, concept: Concept, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('conceptsPutOne', 'objectId', objectId)
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPutOne', 'concept', concept)
            const localVarPath = `/v1/concepts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Concepts  Put Some
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conceptsPutSome: async (concept: Array<Concept>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'concept' is not null or undefined
            assertParamExists('conceptsPutSome', 'concept', concept)
            const localVarPath = `/v1/concepts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(concept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('diseasesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('diseasesGetSome', 'ids', ids)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Post One
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostOne: async (disease: Disease, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPostOne', 'disease', disease)
            const localVarPath = `/v1/diseases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('diseasesPostQuery', 'filter', filter)
            const localVarPath = `/v1/diseases/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('diseasesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/diseases/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Post Some
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPostSome: async (disease: Array<Disease>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPostSome', 'disease', disease)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disease Etiologicalagent
         * @param {string} diseaseId 
         * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutEtiologicalAgents: async (diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'diseaseId' is not null or undefined
            assertParamExists('diseasesPutEtiologicalAgents', 'diseaseId', diseaseId)
            // verify required parameter 'updateDiseaseEtiologicalAgentRequestBody' is not null or undefined
            assertParamExists('diseasesPutEtiologicalAgents', 'updateDiseaseEtiologicalAgentRequestBody', updateDiseaseEtiologicalAgentRequestBody)
            const localVarPath = `/v1/diseases/{disease_id}/etiological_agents`
                .replace(`{${"disease_id"}}`, encodeURIComponent(String(diseaseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDiseaseEtiologicalAgentRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Put One
         * @param {string} objectId 
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutOne: async (objectId: string, disease: Disease, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('diseasesPutOne', 'objectId', objectId)
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPutOne', 'disease', disease)
            const localVarPath = `/v1/diseases/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Diseases  Put Some
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        diseasesPutSome: async (disease: Array<Disease>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disease' is not null or undefined
            assertParamExists('diseasesPutSome', 'disease', disease)
            const localVarPath = `/v1/diseases/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disease, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologicalAgentsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologicalAgentsGetSome', 'ids', ids)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Post One
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostOne: async (etiologicalAgent: EtiologicalAgent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPostOne', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologicalAgentsPostQuery', 'filter', filter)
            const localVarPath = `/v1/etiological_agents/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologicalAgentsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/etiological_agents/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Post Some
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPostSome: async (etiologicalAgent: Array<EtiologicalAgent>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPostSome', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Put One
         * @param {string} objectId 
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPutOne: async (objectId: string, etiologicalAgent: EtiologicalAgent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologicalAgentsPutOne', 'objectId', objectId)
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPutOne', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiological Agents  Put Some
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologicalAgentsPutSome: async (etiologicalAgent: Array<EtiologicalAgent>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiologicalAgent' is not null or undefined
            assertParamExists('etiologicalAgentsPutSome', 'etiologicalAgent', etiologicalAgent)
            const localVarPath = `/v1/etiological_agents/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiologicalAgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologiesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('etiologiesGetSome', 'ids', ids)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Post One
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostOne: async (etiology: Etiology, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPostOne', 'etiology', etiology)
            const localVarPath = `/v1/etiologies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologiesPostQuery', 'filter', filter)
            const localVarPath = `/v1/etiologies/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('etiologiesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/etiologies/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Post Some
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPostSome: async (etiology: Array<Etiology>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPostSome', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Put One
         * @param {string} objectId 
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPutOne: async (objectId: string, etiology: Etiology, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('etiologiesPutOne', 'objectId', objectId)
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPutOne', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Etiologies  Put Some
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        etiologiesPutSome: async (etiology: Array<Etiology>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'etiology' is not null or undefined
            assertParamExists('etiologiesPutSome', 'etiology', etiology)
            const localVarPath = `/v1/etiologies/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(etiology, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OntologyApi - functional programming interface
 * @export
 */
const OntologyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OntologyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Concept Relations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Post One
         * @param {ConceptRelation} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPostOne(conceptRelation: ConceptRelation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPostOne(conceptRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Post Some
         * @param {Array<ConceptRelation>} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPostSome(conceptRelation: Array<ConceptRelation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPostSome(conceptRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Put One
         * @param {string} objectId 
         * @param {ConceptRelation} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPutOne(objectId: string, conceptRelation: ConceptRelation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPutOne(objectId, conceptRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Relations  Put Some
         * @param {Array<ConceptRelation>} conceptRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptRelationsPutSome(conceptRelation: Array<ConceptRelation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptRelation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptRelationsPutSome(conceptRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptRelationsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Post One
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostOne(conceptSet: ConceptSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostOne(conceptSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Post Some
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPostSome(conceptSet: Array<ConceptSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPostSome(conceptSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Put One
         * @param {string} objectId 
         * @param {ConceptSet} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPutOne(objectId: string, conceptSet: ConceptSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConceptSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPutOne(objectId, conceptSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concept Sets  Put Some
         * @param {Array<ConceptSet>} conceptSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptSetsPutSome(conceptSet: Array<ConceptSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConceptSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptSetsPutSome(conceptSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Post One
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostOne(concept: Concept, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostOne(concept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Post Some
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPostSome(concept: Array<Concept>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPostSome(concept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Put One
         * @param {string} objectId 
         * @param {Concept} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPutOne(objectId: string, concept: Concept, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Concept>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPutOne(objectId, concept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Concepts  Put Some
         * @param {Array<Concept>} concept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conceptsPutSome(concept: Array<Concept>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Concept>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conceptsPutSome(concept, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.conceptsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Post One
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostOne(disease: Disease, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostOne(disease, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Post Some
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPostSome(disease: Array<Disease>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPostSome(disease, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disease Etiologicalagent
         * @param {string} diseaseId 
         * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutEtiologicalAgents(diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutEtiologicalAgents(diseaseId, updateDiseaseEtiologicalAgentRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPutEtiologicalAgents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Put One
         * @param {string} objectId 
         * @param {Disease} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutOne(objectId: string, disease: Disease, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutOne(objectId, disease, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Diseases  Put Some
         * @param {Array<Disease>} disease 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async diseasesPutSome(disease: Array<Disease>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disease>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.diseasesPutSome(disease, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.diseasesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Post One
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostOne(etiologicalAgent: EtiologicalAgent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostOne(etiologicalAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Post Some
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPostSome(etiologicalAgent: Array<EtiologicalAgent>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPostSome(etiologicalAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Put One
         * @param {string} objectId 
         * @param {EtiologicalAgent} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPutOne(objectId: string, etiologicalAgent: EtiologicalAgent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EtiologicalAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPutOne(objectId, etiologicalAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiological Agents  Put Some
         * @param {Array<EtiologicalAgent>} etiologicalAgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologicalAgentsPutSome(etiologicalAgent: Array<EtiologicalAgent>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EtiologicalAgent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologicalAgentsPutSome(etiologicalAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologicalAgentsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Post One
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostOne(etiology: Etiology, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostOne(etiology, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Post Some
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPostSome(etiology: Array<Etiology>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPostSome(etiology, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Put One
         * @param {string} objectId 
         * @param {Etiology} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPutOne(objectId: string, etiology: Etiology, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Etiology>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPutOne(objectId, etiology, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Etiologies  Put Some
         * @param {Array<Etiology>} etiology 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async etiologiesPutSome(etiology: Array<Etiology>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Etiology>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.etiologiesPutSome(etiology, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OntologyApi.etiologiesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OntologyApi - factory interface
 * @export
 */

/**
 * OntologyApi - object-oriented interface

 * @export
 * @class OntologyApi
 * @extends {BaseAPI}
 */
export class OntologyApi extends BaseAPI {
  private static __instance: OntologyApi;
  public static get instance(): OntologyApi {
    OntologyApi.__instance = OntologyApi.__instance || new OntologyApi();
    return OntologyApi.__instance;
  }

    /**
     * 
     * @summary Concept Relations  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Post One
     * @param {ConceptRelation} conceptRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPostOne(conceptRelation: ConceptRelation, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPostOne(conceptRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Post Some
     * @param {Array<ConceptRelation>} conceptRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPostSome(conceptRelation: Array<ConceptRelation>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPostSome(conceptRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Put One
     * @param {string} objectId 
     * @param {ConceptRelation} conceptRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPutOne(objectId: string, conceptRelation: ConceptRelation, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPutOne(objectId, conceptRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Relations  Put Some
     * @param {Array<ConceptRelation>} conceptRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptRelationsPutSome(conceptRelation: Array<ConceptRelation>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptRelationsPutSome(conceptRelation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Post One
     * @param {ConceptSet} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostOne(conceptSet: ConceptSet, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostOne(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Post Some
     * @param {Array<ConceptSet>} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPostSome(conceptSet: Array<ConceptSet>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPostSome(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Put One
     * @param {string} objectId 
     * @param {ConceptSet} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPutOne(objectId: string, conceptSet: ConceptSet, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPutOne(objectId, conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concept Sets  Put Some
     * @param {Array<ConceptSet>} conceptSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptSetsPutSome(conceptSet: Array<ConceptSet>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptSetsPutSome(conceptSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Post One
     * @param {Concept} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostOne(concept: Concept, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostOne(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Post Some
     * @param {Array<Concept>} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPostSome(concept: Array<Concept>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPostSome(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Put One
     * @param {string} objectId 
     * @param {Concept} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPutOne(objectId: string, concept: Concept, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPutOne(objectId, concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Concepts  Put Some
     * @param {Array<Concept>} concept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public conceptsPutSome(concept: Array<Concept>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).conceptsPutSome(concept, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Post One
     * @param {Disease} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostOne(disease: Disease, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostOne(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Post Some
     * @param {Array<Disease>} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPostSome(disease: Array<Disease>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPostSome(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Disease Etiologicalagent
     * @param {string} diseaseId 
     * @param {UpdateDiseaseEtiologicalAgentRequestBody} updateDiseaseEtiologicalAgentRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutEtiologicalAgents(diseaseId: string, updateDiseaseEtiologicalAgentRequestBody: UpdateDiseaseEtiologicalAgentRequestBody, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutEtiologicalAgents(diseaseId, updateDiseaseEtiologicalAgentRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Put One
     * @param {string} objectId 
     * @param {Disease} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutOne(objectId: string, disease: Disease, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutOne(objectId, disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Diseases  Put Some
     * @param {Array<Disease>} disease 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public diseasesPutSome(disease: Array<Disease>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).diseasesPutSome(disease, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Post One
     * @param {EtiologicalAgent} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostOne(etiologicalAgent: EtiologicalAgent, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostOne(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Post Some
     * @param {Array<EtiologicalAgent>} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPostSome(etiologicalAgent: Array<EtiologicalAgent>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPostSome(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Put One
     * @param {string} objectId 
     * @param {EtiologicalAgent} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPutOne(objectId: string, etiologicalAgent: EtiologicalAgent, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPutOne(objectId, etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiological Agents  Put Some
     * @param {Array<EtiologicalAgent>} etiologicalAgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologicalAgentsPutSome(etiologicalAgent: Array<EtiologicalAgent>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologicalAgentsPutSome(etiologicalAgent, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetAll(options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Post One
     * @param {Etiology} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostOne(etiology: Etiology, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostOne(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Post Some
     * @param {Array<Etiology>} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPostSome(etiology: Array<Etiology>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPostSome(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Put One
     * @param {string} objectId 
     * @param {Etiology} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPutOne(objectId: string, etiology: Etiology, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPutOne(objectId, etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Etiologies  Put Some
     * @param {Array<Etiology>} etiology 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyApi
     */
    public etiologiesPutSome(etiology: Array<Etiology>, options?: RawAxiosRequestConfig) {
        return OntologyApiFp(this.configuration).etiologiesPutSome(etiology, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Contacts  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('contactsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('contactsGetSome', 'ids', ids)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Post One
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostOne: async (contact: Contact, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPostOne', 'contact', contact)
            const localVarPath = `/v1/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('contactsPostQuery', 'filter', filter)
            const localVarPath = `/v1/contacts/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('contactsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/contacts/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Post Some
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPostSome: async (contact: Array<Contact>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPostSome', 'contact', contact)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Put One
         * @param {string} objectId 
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPutOne: async (objectId: string, contact: Contact, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('contactsPutOne', 'objectId', objectId)
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPutOne', 'contact', contact)
            const localVarPath = `/v1/contacts/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Contacts  Put Some
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactsPutSome: async (contact: Array<Contact>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contact' is not null or undefined
            assertParamExists('contactsPutSome', 'contact', contact)
            const localVarPath = `/v1/contacts/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Post One
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostOne: async (dataCollectionSetMember: DataCollectionSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostOne', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collection_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collection_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Some
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPostSome: async (dataCollectionSetMember: Array<DataCollectionSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPostSome', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Put One
         * @param {string} objectId 
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPutOne: async (objectId: string, dataCollectionSetMember: DataCollectionSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutOne', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Set Members  Put Some
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetMembersPutSome: async (dataCollectionSetMember: Array<DataCollectionSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetMember' is not null or undefined
            assertParamExists('dataCollectionSetMembersPutSome', 'dataCollectionSetMember', dataCollectionSetMember)
            const localVarPath = `/v1/data_collection_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Post One
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostOne: async (dataCollectionSet: DataCollectionSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPostOne', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collection_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collection_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Post Some
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPostSome: async (dataCollectionSet: Array<DataCollectionSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPostSome', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the association between DataCollectionSets and DataCollections.  This command manages the many-to-many relationship by creating or updating DataCollectionSetMember associations between data collection sets and individual data collections.
         * @summary Datacollectionset Datacollection
         * @param {string} dataCollectionSetId 
         * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutDataCollections: async (dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSetId' is not null or undefined
            assertParamExists('dataCollectionSetsPutDataCollections', 'dataCollectionSetId', dataCollectionSetId)
            // verify required parameter 'updateDataCollectionSetDataCollectionRequestBody' is not null or undefined
            assertParamExists('dataCollectionSetsPutDataCollections', 'updateDataCollectionSetDataCollectionRequestBody', updateDataCollectionSetDataCollectionRequestBody)
            const localVarPath = `/v1/data_collection_sets/{data_collection_set_id}/data_collections`
                .replace(`{${"data_collection_set_id"}}`, encodeURIComponent(String(dataCollectionSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataCollectionSetDataCollectionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Put One
         * @param {string} objectId 
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutOne: async (objectId: string, dataCollectionSet: DataCollectionSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionSetsPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPutOne', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collection Sets  Put Some
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionSetsPutSome: async (dataCollectionSet: Array<DataCollectionSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollectionSet' is not null or undefined
            assertParamExists('dataCollectionSetsPutSome', 'dataCollectionSet', dataCollectionSet)
            const localVarPath = `/v1/data_collection_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollectionSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('dataCollectionsGetSome', 'ids', ids)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Post One
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostOne: async (dataCollection: DataCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPostOne', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionsPostQuery', 'filter', filter)
            const localVarPath = `/v1/data_collections/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('dataCollectionsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/data_collections/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Post Some
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPostSome: async (dataCollection: Array<DataCollection>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPostSome', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Put One
         * @param {string} objectId 
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPutOne: async (objectId: string, dataCollection: DataCollection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('dataCollectionsPutOne', 'objectId', objectId)
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPutOne', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Data Collections  Put Some
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dataCollectionsPutSome: async (dataCollection: Array<DataCollection>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataCollection' is not null or undefined
            assertParamExists('dataCollectionsPutSome', 'dataCollection', dataCollection)
            const localVarPath = `/v1/data_collections/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataCollection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/external_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('externalIdentifiersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/external_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('externalIdentifiersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/external_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/external_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('externalIdentifiersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/external_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('externalIdentifiersGetSome', 'ids', ids)
            const localVarPath = `/v1/external_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Post One
         * @param {ExternalIdentifier} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPostOne: async (externalIdentifier: ExternalIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalIdentifier' is not null or undefined
            assertParamExists('externalIdentifiersPostOne', 'externalIdentifier', externalIdentifier)
            const localVarPath = `/v1/external_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('externalIdentifiersPostQuery', 'filter', filter)
            const localVarPath = `/v1/external_identifiers/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('externalIdentifiersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/external_identifiers/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Post Some
         * @param {Array<ExternalIdentifier>} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPostSome: async (externalIdentifier: Array<ExternalIdentifier>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalIdentifier' is not null or undefined
            assertParamExists('externalIdentifiersPostSome', 'externalIdentifier', externalIdentifier)
            const localVarPath = `/v1/external_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Put One
         * @param {string} objectId 
         * @param {ExternalIdentifier} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPutOne: async (objectId: string, externalIdentifier: ExternalIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('externalIdentifiersPutOne', 'objectId', objectId)
            // verify required parameter 'externalIdentifier' is not null or undefined
            assertParamExists('externalIdentifiersPutOne', 'externalIdentifier', externalIdentifier)
            const localVarPath = `/v1/external_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary External Identifiers  Put Some
         * @param {Array<ExternalIdentifier>} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalIdentifiersPutSome: async (externalIdentifier: Array<ExternalIdentifier>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalIdentifier' is not null or undefined
            assertParamExists('externalIdentifiersPutSome', 'externalIdentifier', externalIdentifier)
            const localVarPath = `/v1/external_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('identifierIssuersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('identifierIssuersGetSome', 'ids', ids)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Post One
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostOne: async (identifierIssuer: IdentifierIssuer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPostOne', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('identifierIssuersPostQuery', 'filter', filter)
            const localVarPath = `/v1/identifier_issuers/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('identifierIssuersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/identifier_issuers/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Post Some
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPostSome: async (identifierIssuer: Array<IdentifierIssuer>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPostSome', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Put One
         * @param {string} objectId 
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPutOne: async (objectId: string, identifierIssuer: IdentifierIssuer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('identifierIssuersPutOne', 'objectId', objectId)
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPutOne', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Identifier Issuers  Put Some
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifierIssuersPutSome: async (identifierIssuer: Array<IdentifierIssuer>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifierIssuer' is not null or undefined
            assertParamExists('identifierIssuersPutSome', 'identifierIssuer', identifierIssuer)
            const localVarPath = `/v1/identifier_issuers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identifierIssuer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and returns a UserInvitation for a new user with a particular user key claim (e.g. email address), organization and initial role(s).  A random unique token is added to the invitation, and to be provided to the new user for consuming the invitation.
         * @summary Invite A User
         * @param {UserInvitationRequestBody} userInvitationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUser: async (userInvitationRequestBody: UserInvitationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvitationRequestBody' is not null or undefined
            assertParamExists('inviteUser', 'userInvitationRequestBody', userInvitationRequestBody)
            const localVarPath = `/v1/invite_user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the constraints for inviting a user, such as valid roles and organizations.  This command is used to gather the necessary information for the user invitation process.
         * @summary The Constraints For Inviting A User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteUserConstraints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/invite_user/constraints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_identifier_issuer_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_identifier_issuer_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_identifier_issuer_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_identifier_issuer_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_identifier_issuer_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_identifier_issuer_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post One
         * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPostOne: async (organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationIdentifierIssuerLink' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPostOne', 'organizationIdentifierIssuerLink', organizationIdentifierIssuerLink)
            const localVarPath = `/v1/organization_identifier_issuer_links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationIdentifierIssuerLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_identifier_issuer_links/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_identifier_issuer_links/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Some
         * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPostSome: async (organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationIdentifierIssuerLink' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPostSome', 'organizationIdentifierIssuerLink', organizationIdentifierIssuerLink)
            const localVarPath = `/v1/organization_identifier_issuer_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationIdentifierIssuerLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Put One
         * @param {string} objectId 
         * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPutOne: async (objectId: string, organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPutOne', 'objectId', objectId)
            // verify required parameter 'organizationIdentifierIssuerLink' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPutOne', 'organizationIdentifierIssuerLink', organizationIdentifierIssuerLink)
            const localVarPath = `/v1/organization_identifier_issuer_links/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationIdentifierIssuerLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Put Some
         * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationIdentifierIssuerLinksPutSome: async (organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationIdentifierIssuerLink' is not null or undefined
            assertParamExists('organizationIdentifierIssuerLinksPutSome', 'organizationIdentifierIssuerLink', organizationIdentifierIssuerLink)
            const localVarPath = `/v1/organization_identifier_issuer_links/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationIdentifierIssuerLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetMembersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetMembersGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Post One
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostOne: async (organizationSetMember: OrganizationSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPostOne', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetMembersPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_set_members/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetMembersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_set_members/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Post Some
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPostSome: async (organizationSetMember: Array<OrganizationSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPostSome', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Put One
         * @param {string} objectId 
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPutOne: async (objectId: string, organizationSetMember: OrganizationSetMember, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetMembersPutOne', 'objectId', objectId)
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPutOne', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Set Members  Put Some
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetMembersPutSome: async (organizationSetMember: Array<OrganizationSetMember>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetMember' is not null or undefined
            assertParamExists('organizationSetMembersPutSome', 'organizationSetMember', organizationSetMember)
            const localVarPath = `/v1/organization_set_members/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSetMember, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationSetsGetSome', 'ids', ids)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Post One
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostOne: async (organizationSet: OrganizationSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPostOne', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetsPostQuery', 'filter', filter)
            const localVarPath = `/v1/organization_sets/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationSetsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organization_sets/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Post Some
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPostSome: async (organizationSet: Array<OrganizationSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPostSome', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Put One
         * @param {string} objectId 
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutOne: async (objectId: string, organizationSet: OrganizationSet, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationSetsPutOne', 'objectId', objectId)
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPutOne', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the association between an OrganizationSets and Organizations.  This command manages the many-to-many relationship by creating or updating OrganizationSetMember associations between organization sets and individual organizations.
         * @summary Organizationset Organization
         * @param {string} organizationSetId 
         * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutOrganizations: async (organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSetId' is not null or undefined
            assertParamExists('organizationSetsPutOrganizations', 'organizationSetId', organizationSetId)
            // verify required parameter 'updateOrganizationSetOrganizationRequestBody' is not null or undefined
            assertParamExists('organizationSetsPutOrganizations', 'updateOrganizationSetOrganizationRequestBody', updateOrganizationSetOrganizationRequestBody)
            const localVarPath = `/v1/organization_sets/{organization_set_id}/organizations`
                .replace(`{${"organization_set_id"}}`, encodeURIComponent(String(organizationSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationSetOrganizationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organization Sets  Put Some
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationSetsPutSome: async (organizationSet: Array<OrganizationSet>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationSet' is not null or undefined
            assertParamExists('organizationSetsPutSome', 'organizationSet', organizationSet)
            const localVarPath = `/v1/organization_sets/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationSet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/organizations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/organizations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('organizationsGetSome', 'ids', ids)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Post One
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostOne: async (organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPostOne', 'organization', organization)
            const localVarPath = `/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/organizations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('organizationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/organizations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Post Some
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPostSome: async (organization: Array<Organization>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPostSome', 'organization', organization)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Association Between Organization And Identifierissuer
         * @param {string} organizationId 
         * @param {UpdateOrganizationIdentifierIssuerLinksRequestBody} updateOrganizationIdentifierIssuerLinksRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPutIdentifierIssuers: async (organizationId: string, updateOrganizationIdentifierIssuerLinksRequestBody: UpdateOrganizationIdentifierIssuerLinksRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('organizationsPutIdentifierIssuers', 'organizationId', organizationId)
            // verify required parameter 'updateOrganizationIdentifierIssuerLinksRequestBody' is not null or undefined
            assertParamExists('organizationsPutIdentifierIssuers', 'updateOrganizationIdentifierIssuerLinksRequestBody', updateOrganizationIdentifierIssuerLinksRequestBody)
            const localVarPath = `/v1/organizations/{organization_id}/identifier_issuers`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationIdentifierIssuerLinksRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Put One
         * @param {string} objectId 
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPutOne: async (objectId: string, organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('organizationsPutOne', 'objectId', objectId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPutOne', 'organization', organization)
            const localVarPath = `/v1/organizations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Organizations  Put Some
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsPutSome: async (organization: Array<Organization>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('organizationsPutSome', 'organization', organization)
            const localVarPath = `/v1/organizations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('sitesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('sitesGetSome', 'ids', ids)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Post One
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostOne: async (site: Site, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPostOne', 'site', site)
            const localVarPath = `/v1/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('sitesPostQuery', 'filter', filter)
            const localVarPath = `/v1/sites/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('sitesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/sites/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Post Some
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPostSome: async (site: Array<Site>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPostSome', 'site', site)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Put One
         * @param {string} objectId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPutOne: async (objectId: string, site: Site, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('sitesPutOne', 'objectId', objectId)
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPutOne', 'site', site)
            const localVarPath = `/v1/sites/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sites  Put Some
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPutSome: async (site: Array<Site>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'site' is not null or undefined
            assertParamExists('sitesPutSome', 'site', site)
            const localVarPath = `/v1/sites/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(site, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing User with new properties such as active status, roles, and organization membership.  The target user is identified by tgt_user_id. Any field set to None will leave that property unchanged. Roles cannot be set to an empty set. Cache is invalidated after successful update.
         * @summary Updateuser
         * @param {string} objectId 
         * @param {UpdateUserRequestBody} updateUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (objectId: string, updateUserRequestBody: UpdateUserRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('updateUser', 'objectId', objectId)
            // verify required parameter 'updateUserRequestBody' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequestBody', updateUserRequestBody)
            const localVarPath = `/v1/update_user/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the current user\'s Organization membership.  This command allows a user to change their own organization association. The is_new_user flag indicates whether this is part of a new user registration process.
         * @summary Updateuserownorganizationcommand
         * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserOwnOrganization: async (updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserOwnOrganizationRequestBody' is not null or undefined
            assertParamExists('updateUserOwnOrganization', 'updateUserOwnOrganizationRequestBody', updateUserOwnOrganizationRequestBody)
            const localVarPath = `/v1/update_user_own_organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserOwnOrganizationRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userInvitationsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/user_invitations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userInvitationsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userInvitationsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/user_invitations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('userInvitationsGetSome', 'ids', ids)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Post One
         * @param {UserInvitation} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostOne: async (userInvitation: UserInvitation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvitation' is not null or undefined
            assertParamExists('userInvitationsPostOne', 'userInvitation', userInvitation)
            const localVarPath = `/v1/user_invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userInvitationsPostQuery', 'filter', filter)
            const localVarPath = `/v1/user_invitations/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('userInvitationsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/user_invitations/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Post Some
         * @param {Array<UserInvitation>} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPostSome: async (userInvitation: Array<UserInvitation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvitation' is not null or undefined
            assertParamExists('userInvitationsPostSome', 'userInvitation', userInvitation)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Put One
         * @param {string} objectId 
         * @param {UserInvitation} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPutOne: async (objectId: string, userInvitation: UserInvitation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userInvitationsPutOne', 'objectId', objectId)
            // verify required parameter 'userInvitation' is not null or undefined
            assertParamExists('userInvitationsPutOne', 'userInvitation', userInvitation)
            const localVarPath = `/v1/user_invitations/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Invitations  Put Some
         * @param {Array<UserInvitation>} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvitationsPutSome: async (userInvitation: Array<UserInvitation>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userInvitation' is not null or undefined
            assertParamExists('userInvitationsPutSome', 'userInvitation', userInvitation)
            const localVarPath = `/v1/user_invitations/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userInvitation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Userme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeGetOne: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Userme Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeRetrievePermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user_me/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers (creates) the user of the command. The key and token must match that of an existing UserInvitation. The newly registered user is assigned the organization and roles from the invitation. The invitation is deleted.
         * @summary Registerinviteduser
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistrationsPostOne: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userRegistrationsPostOne', 'token', token)
            const localVarPath = `/v1/user_registrations/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('usersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/users/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('usersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/users/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('usersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/users/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('usersGetSome', 'ids', ids)
            const localVarPath = `/v1/users/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Post One
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostOne: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPostOne', 'user', user)
            const localVarPath = `/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('usersPostQuery', 'filter', filter)
            const localVarPath = `/v1/users/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('usersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/users/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Post Some
         * @param {Array<User>} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPostSome: async (user: Array<User>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPostSome', 'user', user)
            const localVarPath = `/v1/users/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Put One
         * @param {string} objectId 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPutOne: async (objectId: string, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('usersPutOne', 'objectId', objectId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPutOne', 'user', user)
            const localVarPath = `/v1/users/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Users  Put Some
         * @param {Array<User>} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPutSome: async (user: Array<User>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPutSome', 'user', user)
            const localVarPath = `/v1/users/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Contacts  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Post One
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostOne(contact: Contact, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostOne(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Post Some
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPostSome(contact: Array<Contact>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPostSome(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Put One
         * @param {string} objectId 
         * @param {Contact} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPutOne(objectId: string, contact: Contact, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPutOne(objectId, contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Contacts  Put Some
         * @param {Array<Contact>} contact 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contactsPutSome(contact: Array<Contact>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contactsPutSome(contact, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.contactsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Post One
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostOne(dataCollectionSetMember: DataCollectionSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostOne(dataCollectionSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Post Some
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPostSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPostSome(dataCollectionSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Put One
         * @param {string} objectId 
         * @param {DataCollectionSetMember} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPutOne(objectId: string, dataCollectionSetMember: DataCollectionSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPutOne(objectId, dataCollectionSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Set Members  Put Some
         * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetMembersPutSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetMembersPutSome(dataCollectionSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetMembersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Post One
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostOne(dataCollectionSet: DataCollectionSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostOne(dataCollectionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Post Some
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPostSome(dataCollectionSet: Array<DataCollectionSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPostSome(dataCollectionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the association between DataCollectionSets and DataCollections.  This command manages the many-to-many relationship by creating or updating DataCollectionSetMember associations between data collection sets and individual data collections.
         * @summary Datacollectionset Datacollection
         * @param {string} dataCollectionSetId 
         * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutDataCollections(dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutDataCollections(dataCollectionSetId, updateDataCollectionSetDataCollectionRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPutDataCollections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Put One
         * @param {string} objectId 
         * @param {DataCollectionSet} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutOne(objectId: string, dataCollectionSet: DataCollectionSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollectionSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutOne(objectId, dataCollectionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collection Sets  Put Some
         * @param {Array<DataCollectionSet>} dataCollectionSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionSetsPutSome(dataCollectionSet: Array<DataCollectionSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollectionSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionSetsPutSome(dataCollectionSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Post One
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostOne(dataCollection: DataCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostOne(dataCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Post Some
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPostSome(dataCollection: Array<DataCollection>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPostSome(dataCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Put One
         * @param {string} objectId 
         * @param {DataCollection} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPutOne(objectId: string, dataCollection: DataCollection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPutOne(objectId, dataCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Data Collections  Put Some
         * @param {Array<DataCollection>} dataCollection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dataCollectionsPutSome(dataCollection: Array<DataCollection>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataCollection>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dataCollectionsPutSome(dataCollection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.dataCollectionsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Post One
         * @param {ExternalIdentifier} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPostOne(externalIdentifier: ExternalIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPostOne(externalIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Post Some
         * @param {Array<ExternalIdentifier>} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPostSome(externalIdentifier: Array<ExternalIdentifier>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPostSome(externalIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Put One
         * @param {string} objectId 
         * @param {ExternalIdentifier} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPutOne(objectId: string, externalIdentifier: ExternalIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPutOne(objectId, externalIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary External Identifiers  Put Some
         * @param {Array<ExternalIdentifier>} externalIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalIdentifiersPutSome(externalIdentifier: Array<ExternalIdentifier>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalIdentifiersPutSome(externalIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.externalIdentifiersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Post One
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostOne(identifierIssuer: IdentifierIssuer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostOne(identifierIssuer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Post Some
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPostSome(identifierIssuer: Array<IdentifierIssuer>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPostSome(identifierIssuer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Put One
         * @param {string} objectId 
         * @param {IdentifierIssuer} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPutOne(objectId: string, identifierIssuer: IdentifierIssuer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentifierIssuer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPutOne(objectId, identifierIssuer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Identifier Issuers  Put Some
         * @param {Array<IdentifierIssuer>} identifierIssuer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifierIssuersPutSome(identifierIssuer: Array<IdentifierIssuer>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdentifierIssuer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifierIssuersPutSome(identifierIssuer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.identifierIssuersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and returns a UserInvitation for a new user with a particular user key claim (e.g. email address), organization and initial role(s).  A random unique token is added to the invitation, and to be provided to the new user for consuming the invitation.
         * @summary Invite A User
         * @param {UserInvitationRequestBody} userInvitationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUser(userInvitationRequestBody: UserInvitationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUser(userInvitationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.inviteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the constraints for inviting a user, such as valid roles and organizations.  This command is used to gather the necessary information for the user invitation process.
         * @summary The Constraints For Inviting A User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteUserConstraints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitationConstraints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteUserConstraints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.inviteUserConstraints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationIdentifierIssuerLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post One
         * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPostOne(organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationIdentifierIssuerLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPostOne(organizationIdentifierIssuerLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Post Some
         * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPostSome(organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPostSome(organizationIdentifierIssuerLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Put One
         * @param {string} objectId 
         * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPutOne(objectId: string, organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationIdentifierIssuerLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPutOne(objectId, organizationIdentifierIssuerLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Identifier Issuer Links  Put Some
         * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationIdentifierIssuerLinksPutSome(organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationIdentifierIssuerLinksPutSome(organizationIdentifierIssuerLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationIdentifierIssuerLinksPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Post One
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostOne(organizationSetMember: OrganizationSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostOne(organizationSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Post Some
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPostSome(organizationSetMember: Array<OrganizationSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPostSome(organizationSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Put One
         * @param {string} objectId 
         * @param {OrganizationSetMember} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPutOne(objectId: string, organizationSetMember: OrganizationSetMember, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSetMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPutOne(objectId, organizationSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Set Members  Put Some
         * @param {Array<OrganizationSetMember>} organizationSetMember 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetMembersPutSome(organizationSetMember: Array<OrganizationSetMember>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetMembersPutSome(organizationSetMember, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetMembersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Post One
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostOne(organizationSet: OrganizationSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostOne(organizationSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Post Some
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPostSome(organizationSet: Array<OrganizationSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPostSome(organizationSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Put One
         * @param {string} objectId 
         * @param {OrganizationSet} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutOne(objectId: string, organizationSet: OrganizationSet, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutOne(objectId, organizationSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the association between an OrganizationSets and Organizations.  This command manages the many-to-many relationship by creating or updating OrganizationSetMember associations between organization sets and individual organizations.
         * @summary Organizationset Organization
         * @param {string} organizationSetId 
         * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutOrganizations(organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSetMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutOrganizations(organizationSetId, updateOrganizationSetOrganizationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPutOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organization Sets  Put Some
         * @param {Array<OrganizationSet>} organizationSet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationSetsPutSome(organizationSet: Array<OrganizationSet>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationSetsPutSome(organizationSet, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationSetsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Post One
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostOne(organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostOne(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Post Some
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPostSome(organization: Array<Organization>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPostSome(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Association Between Organization And Identifierissuer
         * @param {string} organizationId 
         * @param {UpdateOrganizationIdentifierIssuerLinksRequestBody} updateOrganizationIdentifierIssuerLinksRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPutIdentifierIssuers(organizationId: string, updateOrganizationIdentifierIssuerLinksRequestBody: UpdateOrganizationIdentifierIssuerLinksRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationIdentifierIssuerLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPutIdentifierIssuers(organizationId, updateOrganizationIdentifierIssuerLinksRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPutIdentifierIssuers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Put One
         * @param {string} objectId 
         * @param {Organization} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPutOne(objectId: string, organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPutOne(objectId, organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Organizations  Put Some
         * @param {Array<Organization>} organization 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsPutSome(organization: Array<Organization>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsPutSome(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.organizationsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Post One
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostOne(site: Site, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostOne(site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Post Some
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPostSome(site: Array<Site>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPostSome(site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Put One
         * @param {string} objectId 
         * @param {Site} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPutOne(objectId: string, site: Site, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPutOne(objectId, site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sites  Put Some
         * @param {Array<Site>} site 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPutSome(site: Array<Site>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Site>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPutSome(site, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.sitesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing User with new properties such as active status, roles, and organization membership.  The target user is identified by tgt_user_id. Any field set to None will leave that property unchanged. Roles cannot be set to an empty set. Cache is invalidated after successful update.
         * @summary Updateuser
         * @param {string} objectId 
         * @param {UpdateUserRequestBody} updateUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(objectId: string, updateUserRequestBody: UpdateUserRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(objectId, updateUserRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the current user\'s Organization membership.  This command allows a user to change their own organization association. The is_new_user flag indicates whether this is part of a new user registration process.
         * @summary Updateuserownorganizationcommand
         * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserOwnOrganization(updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserOwnOrganization(updateUserOwnOrganizationRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateUserOwnOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Post One
         * @param {UserInvitation} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostOne(userInvitation: UserInvitation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostOne(userInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Post Some
         * @param {Array<UserInvitation>} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPostSome(userInvitation: Array<UserInvitation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPostSome(userInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Put One
         * @param {string} objectId 
         * @param {UserInvitation} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPutOne(objectId: string, userInvitation: UserInvitation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInvitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPutOne(objectId, userInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Invitations  Put Some
         * @param {Array<UserInvitation>} userInvitation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvitationsPutSome(userInvitation: Array<UserInvitation>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserInvitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvitationsPutSome(userInvitation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userInvitationsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Userme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeGetOne(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeGetOne(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userMeGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Userme Permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeRetrievePermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeRetrievePermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userMeRetrievePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers (creates) the user of the command. The key and token must match that of an existing UserInvitation. The newly registered user is assigned the organization and roles from the invitation. The invitation is deleted.
         * @summary Registerinviteduser
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegistrationsPostOne(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegistrationsPostOne(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.userRegistrationsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Post One
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostOne(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostOne(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Post Some
         * @param {Array<User>} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPostSome(user: Array<User>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPostSome(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Put One
         * @param {string} objectId 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPutOne(objectId: string, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPutOne(objectId, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Users  Put Some
         * @param {Array<User>} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPutSome(user: Array<User>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPutSome(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.usersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */

/**
 * OrganizationApi - object-oriented interface

 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
  private static __instance: OrganizationApi;
  public static get instance(): OrganizationApi {
    OrganizationApi.__instance = OrganizationApi.__instance || new OrganizationApi();
    return OrganizationApi.__instance;
  }

    /**
     * 
     * @summary Contacts  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Post One
     * @param {Contact} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostOne(contact: Contact, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostOne(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Post Some
     * @param {Array<Contact>} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPostSome(contact: Array<Contact>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPostSome(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Put One
     * @param {string} objectId 
     * @param {Contact} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPutOne(objectId: string, contact: Contact, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPutOne(objectId, contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Contacts  Put Some
     * @param {Array<Contact>} contact 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public contactsPutSome(contact: Array<Contact>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).contactsPutSome(contact, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Post One
     * @param {DataCollectionSetMember} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostOne(dataCollectionSetMember: DataCollectionSetMember, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostOne(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Post Some
     * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPostSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPostSome(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Put One
     * @param {string} objectId 
     * @param {DataCollectionSetMember} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPutOne(objectId: string, dataCollectionSetMember: DataCollectionSetMember, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPutOne(objectId, dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Set Members  Put Some
     * @param {Array<DataCollectionSetMember>} dataCollectionSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetMembersPutSome(dataCollectionSetMember: Array<DataCollectionSetMember>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetMembersPutSome(dataCollectionSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Post One
     * @param {DataCollectionSet} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostOne(dataCollectionSet: DataCollectionSet, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostOne(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Post Some
     * @param {Array<DataCollectionSet>} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPostSome(dataCollectionSet: Array<DataCollectionSet>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPostSome(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Updates the association between DataCollectionSets and DataCollections.  This command manages the many-to-many relationship by creating or updating DataCollectionSetMember associations between data collection sets and individual data collections.
     * @summary Datacollectionset Datacollection
     * @param {string} dataCollectionSetId 
     * @param {UpdateDataCollectionSetDataCollectionRequestBody} updateDataCollectionSetDataCollectionRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutDataCollections(dataCollectionSetId: string, updateDataCollectionSetDataCollectionRequestBody: UpdateDataCollectionSetDataCollectionRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutDataCollections(dataCollectionSetId, updateDataCollectionSetDataCollectionRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Put One
     * @param {string} objectId 
     * @param {DataCollectionSet} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutOne(objectId: string, dataCollectionSet: DataCollectionSet, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutOne(objectId, dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collection Sets  Put Some
     * @param {Array<DataCollectionSet>} dataCollectionSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionSetsPutSome(dataCollectionSet: Array<DataCollectionSet>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionSetsPutSome(dataCollectionSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Post One
     * @param {DataCollection} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostOne(dataCollection: DataCollection, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostOne(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Post Some
     * @param {Array<DataCollection>} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPostSome(dataCollection: Array<DataCollection>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPostSome(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Put One
     * @param {string} objectId 
     * @param {DataCollection} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPutOne(objectId: string, dataCollection: DataCollection, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPutOne(objectId, dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Data Collections  Put Some
     * @param {Array<DataCollection>} dataCollection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public dataCollectionsPutSome(dataCollection: Array<DataCollection>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).dataCollectionsPutSome(dataCollection, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Post One
     * @param {ExternalIdentifier} externalIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPostOne(externalIdentifier: ExternalIdentifier, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPostOne(externalIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Post Some
     * @param {Array<ExternalIdentifier>} externalIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPostSome(externalIdentifier: Array<ExternalIdentifier>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPostSome(externalIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Put One
     * @param {string} objectId 
     * @param {ExternalIdentifier} externalIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPutOne(objectId: string, externalIdentifier: ExternalIdentifier, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPutOne(objectId, externalIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary External Identifiers  Put Some
     * @param {Array<ExternalIdentifier>} externalIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public externalIdentifiersPutSome(externalIdentifier: Array<ExternalIdentifier>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).externalIdentifiersPutSome(externalIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Post One
     * @param {IdentifierIssuer} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostOne(identifierIssuer: IdentifierIssuer, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostOne(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Post Some
     * @param {Array<IdentifierIssuer>} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPostSome(identifierIssuer: Array<IdentifierIssuer>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPostSome(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Put One
     * @param {string} objectId 
     * @param {IdentifierIssuer} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPutOne(objectId: string, identifierIssuer: IdentifierIssuer, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPutOne(objectId, identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Identifier Issuers  Put Some
     * @param {Array<IdentifierIssuer>} identifierIssuer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public identifierIssuersPutSome(identifierIssuer: Array<IdentifierIssuer>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).identifierIssuersPutSome(identifierIssuer, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Creates and returns a UserInvitation for a new user with a particular user key claim (e.g. email address), organization and initial role(s).  A random unique token is added to the invitation, and to be provided to the new user for consuming the invitation.
     * @summary Invite A User
     * @param {UserInvitationRequestBody} userInvitationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public inviteUser(userInvitationRequestBody: UserInvitationRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).inviteUser(userInvitationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Retrieves the constraints for inviting a user, such as valid roles and organizations.  This command is used to gather the necessary information for the user invitation process.
     * @summary The Constraints For Inviting A User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public inviteUserConstraints(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).inviteUserConstraints(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Post One
     * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPostOne(organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPostOne(organizationIdentifierIssuerLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Post Some
     * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPostSome(organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPostSome(organizationIdentifierIssuerLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Put One
     * @param {string} objectId 
     * @param {OrganizationIdentifierIssuerLink} organizationIdentifierIssuerLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPutOne(objectId: string, organizationIdentifierIssuerLink: OrganizationIdentifierIssuerLink, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPutOne(objectId, organizationIdentifierIssuerLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Identifier Issuer Links  Put Some
     * @param {Array<OrganizationIdentifierIssuerLink>} organizationIdentifierIssuerLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationIdentifierIssuerLinksPutSome(organizationIdentifierIssuerLink: Array<OrganizationIdentifierIssuerLink>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationIdentifierIssuerLinksPutSome(organizationIdentifierIssuerLink, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Post One
     * @param {OrganizationSetMember} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostOne(organizationSetMember: OrganizationSetMember, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostOne(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Post Some
     * @param {Array<OrganizationSetMember>} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPostSome(organizationSetMember: Array<OrganizationSetMember>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPostSome(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Put One
     * @param {string} objectId 
     * @param {OrganizationSetMember} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPutOne(objectId: string, organizationSetMember: OrganizationSetMember, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPutOne(objectId, organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Set Members  Put Some
     * @param {Array<OrganizationSetMember>} organizationSetMember 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetMembersPutSome(organizationSetMember: Array<OrganizationSetMember>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetMembersPutSome(organizationSetMember, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Post One
     * @param {OrganizationSet} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostOne(organizationSet: OrganizationSet, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostOne(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Post Some
     * @param {Array<OrganizationSet>} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPostSome(organizationSet: Array<OrganizationSet>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPostSome(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Put One
     * @param {string} objectId 
     * @param {OrganizationSet} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutOne(objectId: string, organizationSet: OrganizationSet, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutOne(objectId, organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Updates the association between an OrganizationSets and Organizations.  This command manages the many-to-many relationship by creating or updating OrganizationSetMember associations between organization sets and individual organizations.
     * @summary Organizationset Organization
     * @param {string} organizationSetId 
     * @param {UpdateOrganizationSetOrganizationRequestBody} updateOrganizationSetOrganizationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutOrganizations(organizationSetId: string, updateOrganizationSetOrganizationRequestBody: UpdateOrganizationSetOrganizationRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutOrganizations(organizationSetId, updateOrganizationSetOrganizationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organization Sets  Put Some
     * @param {Array<OrganizationSet>} organizationSet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationSetsPutSome(organizationSet: Array<OrganizationSet>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationSetsPutSome(organizationSet, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Post One
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostOne(organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostOne(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Post Some
     * @param {Array<Organization>} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPostSome(organization: Array<Organization>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPostSome(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Update Association Between Organization And Identifierissuer
     * @param {string} organizationId 
     * @param {UpdateOrganizationIdentifierIssuerLinksRequestBody} updateOrganizationIdentifierIssuerLinksRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPutIdentifierIssuers(organizationId: string, updateOrganizationIdentifierIssuerLinksRequestBody: UpdateOrganizationIdentifierIssuerLinksRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPutIdentifierIssuers(organizationId, updateOrganizationIdentifierIssuerLinksRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Put One
     * @param {string} objectId 
     * @param {Organization} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPutOne(objectId: string, organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPutOne(objectId, organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Organizations  Put Some
     * @param {Array<Organization>} organization 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public organizationsPutSome(organization: Array<Organization>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).organizationsPutSome(organization, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Post One
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostOne(site: Site, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostOne(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Post Some
     * @param {Array<Site>} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPostSome(site: Array<Site>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPostSome(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Put One
     * @param {string} objectId 
     * @param {Site} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPutOne(objectId: string, site: Site, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPutOne(objectId, site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Sites  Put Some
     * @param {Array<Site>} site 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public sitesPutSome(site: Array<Site>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).sitesPutSome(site, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Updates an existing User with new properties such as active status, roles, and organization membership.  The target user is identified by tgt_user_id. Any field set to None will leave that property unchanged. Roles cannot be set to an empty set. Cache is invalidated after successful update.
     * @summary Updateuser
     * @param {string} objectId 
     * @param {UpdateUserRequestBody} updateUserRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateUser(objectId: string, updateUserRequestBody: UpdateUserRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateUser(objectId, updateUserRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Updates the current user\'s Organization membership.  This command allows a user to change their own organization association. The is_new_user flag indicates whether this is part of a new user registration process.
     * @summary Updateuserownorganizationcommand
     * @param {UpdateUserOwnOrganizationRequestBody} updateUserOwnOrganizationRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateUserOwnOrganization(updateUserOwnOrganizationRequestBody: UpdateUserOwnOrganizationRequestBody, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateUserOwnOrganization(updateUserOwnOrganizationRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Post One
     * @param {UserInvitation} userInvitation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostOne(userInvitation: UserInvitation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostOne(userInvitation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Post Some
     * @param {Array<UserInvitation>} userInvitation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPostSome(userInvitation: Array<UserInvitation>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPostSome(userInvitation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Put One
     * @param {string} objectId 
     * @param {UserInvitation} userInvitation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPutOne(objectId: string, userInvitation: UserInvitation, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPutOne(objectId, userInvitation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary User Invitations  Put Some
     * @param {Array<UserInvitation>} userInvitation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userInvitationsPutSome(userInvitation: Array<UserInvitation>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userInvitationsPutSome(userInvitation, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Userme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userMeGetOne(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userMeGetOne(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Userme Permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userMeRetrievePermissions(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userMeRetrievePermissions(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Registers (creates) the user of the command. The key and token must match that of an existing UserInvitation. The newly registered user is assigned the organization and roles from the invitation. The invitation is deleted.
     * @summary Registerinviteduser
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public userRegistrationsPostOne(token: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).userRegistrationsPostOne(token, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersDeleteAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetAll(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Post One
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostOne(user: User, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostOne(user, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Post Some
     * @param {Array<User>} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPostSome(user: Array<User>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPostSome(user, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Put One
     * @param {string} objectId 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPutOne(objectId: string, user: User, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPutOne(objectId, user, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Users  Put Some
     * @param {Array<User>} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public usersPutSome(user: Array<User>, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).usersPutSome(user, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * SubjectApi - axios parameter creator
 * @export
 */
const SubjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary EpiSubject Identifiers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subject_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectIdentifiersDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/subject_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('subjectIdentifiersDeleteSome', 'ids', ids)
            const localVarPath = `/v1/subject_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subject_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectIdentifiersGetOne', 'objectId', objectId)
            const localVarPath = `/v1/subject_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('subjectIdentifiersGetSome', 'ids', ids)
            const localVarPath = `/v1/subject_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post One
         * @param {SubjectIdentifier} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPostOne: async (subjectIdentifier: SubjectIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectIdentifier' is not null or undefined
            assertParamExists('subjectIdentifiersPostOne', 'subjectIdentifier', subjectIdentifier)
            const localVarPath = `/v1/subject_identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subjectIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('subjectIdentifiersPostQuery', 'filter', filter)
            const localVarPath = `/v1/subject_identifiers/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('subjectIdentifiersPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/subject_identifiers/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Some
         * @param {Array<SubjectIdentifier>} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPostSome: async (subjectIdentifier: Array<SubjectIdentifier>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectIdentifier' is not null or undefined
            assertParamExists('subjectIdentifiersPostSome', 'subjectIdentifier', subjectIdentifier)
            const localVarPath = `/v1/subject_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subjectIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Put One
         * @param {string} objectId 
         * @param {SubjectIdentifier} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPutOne: async (objectId: string, subjectIdentifier: SubjectIdentifier, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectIdentifiersPutOne', 'objectId', objectId)
            // verify required parameter 'subjectIdentifier' is not null or undefined
            assertParamExists('subjectIdentifiersPutOne', 'subjectIdentifier', subjectIdentifier)
            const localVarPath = `/v1/subject_identifiers/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subjectIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Put Some
         * @param {Array<SubjectIdentifier>} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectIdentifiersPutSome: async (subjectIdentifier: Array<SubjectIdentifier>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subjectIdentifier' is not null or undefined
            assertParamExists('subjectIdentifiersPutSome', 'subjectIdentifier', subjectIdentifier)
            const localVarPath = `/v1/subject_identifiers/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subjectIdentifier, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subjects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectsDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/subjects/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('subjectsDeleteSome', 'ids', ids)
            const localVarPath = `/v1/subjects/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/subjects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectsGetOne', 'objectId', objectId)
            const localVarPath = `/v1/subjects/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('subjectsGetSome', 'ids', ids)
            const localVarPath = `/v1/subjects/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Post One
         * @param {EpiSubject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPostOne: async (subject: EpiSubject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('subjectsPostOne', 'subject', subject)
            const localVarPath = `/v1/subjects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('subjectsPostQuery', 'filter', filter)
            const localVarPath = `/v1/subjects/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('subjectsPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/subjects/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Post Some
         * @param {Array<EpiSubject>} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPostSome: async (subject: Array<EpiSubject>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('subjectsPostSome', 'subject', subject)
            const localVarPath = `/v1/subjects/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Put One
         * @param {string} objectId 
         * @param {EpiSubject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPutOne: async (objectId: string, subject: EpiSubject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('subjectsPutOne', 'objectId', objectId)
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('subjectsPutOne', 'subject', subject)
            const localVarPath = `/v1/subjects/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subjects  Put Some
         * @param {Array<EpiSubject>} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subjectsPutSome: async (subject: Array<EpiSubject>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subject' is not null or undefined
            assertParamExists('subjectsPutSome', 'subject', subject)
            const localVarPath = `/v1/subjects/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubjectApi - functional programming interface
 * @export
 */
const SubjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary EpiSubject Identifiers  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubjectIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubjectIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubjectIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post One
         * @param {SubjectIdentifier} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPostOne(subjectIdentifier: SubjectIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubjectIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPostOne(subjectIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubjectIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Post Some
         * @param {Array<SubjectIdentifier>} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPostSome(subjectIdentifier: Array<SubjectIdentifier>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubjectIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPostSome(subjectIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Put One
         * @param {string} objectId 
         * @param {SubjectIdentifier} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPutOne(objectId: string, subjectIdentifier: SubjectIdentifier, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubjectIdentifier>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPutOne(objectId, subjectIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary EpiSubject Identifiers  Put Some
         * @param {Array<SubjectIdentifier>} subjectIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectIdentifiersPutSome(subjectIdentifier: Array<SubjectIdentifier>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubjectIdentifier>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectIdentifiersPutSome(subjectIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectIdentifiersPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpiSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpiSubject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpiSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Post One
         * @param {EpiSubject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPostOne(subject: EpiSubject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpiSubject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPostOne(subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpiSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Post Some
         * @param {Array<EpiSubject>} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPostSome(subject: Array<EpiSubject>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpiSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPostSome(subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Put One
         * @param {string} objectId 
         * @param {EpiSubject} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPutOne(objectId: string, subject: EpiSubject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpiSubject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPutOne(objectId, subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Subjects  Put Some
         * @param {Array<EpiSubject>} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subjectsPutSome(subject: Array<EpiSubject>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpiSubject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subjectsPutSome(subject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubjectApi.subjectsPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubjectApi - factory interface
 * @export
 */

/**
 * SubjectApi - object-oriented interface

 * @export
 * @class SubjectApi
 * @extends {BaseAPI}
 */
export class SubjectApi extends BaseAPI {
  private static __instance: SubjectApi;
  public static get instance(): SubjectApi {
    SubjectApi.__instance = SubjectApi.__instance || new SubjectApi();
    return SubjectApi.__instance;
  }

    /**
     * 
     * @summary EpiSubject Identifiers  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersDeleteAll(options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersGetAll(options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Post One
     * @param {SubjectIdentifier} subjectIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPostOne(subjectIdentifier: SubjectIdentifier, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPostOne(subjectIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Post Some
     * @param {Array<SubjectIdentifier>} subjectIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPostSome(subjectIdentifier: Array<SubjectIdentifier>, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPostSome(subjectIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Put One
     * @param {string} objectId 
     * @param {SubjectIdentifier} subjectIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPutOne(objectId: string, subjectIdentifier: SubjectIdentifier, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPutOne(objectId, subjectIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary EpiSubject Identifiers  Put Some
     * @param {Array<SubjectIdentifier>} subjectIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectIdentifiersPutSome(subjectIdentifier: Array<SubjectIdentifier>, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectIdentifiersPutSome(subjectIdentifier, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsDeleteAll(options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsGetAll(options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Post One
     * @param {EpiSubject} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPostOne(subject: EpiSubject, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPostOne(subject, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Post Some
     * @param {Array<EpiSubject>} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPostSome(subject: Array<EpiSubject>, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPostSome(subject, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Put One
     * @param {string} objectId 
     * @param {EpiSubject} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPutOne(objectId: string, subject: EpiSubject, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPutOne(objectId, subject, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Subjects  Put Some
     * @param {Array<EpiSubject>} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public subjectsPutSome(subject: Array<EpiSubject>, options?: RawAxiosRequestConfig) {
        return SubjectApiFp(this.configuration).subjectsPutSome(subject, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the health status of the service. If no response is received within the timeout period, the service is considered unhealthy.
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs the provided log items.
         * @summary Log
         * @param {LogRequestBody} logRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        log: async (logRequestBody: LogRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logRequestBody' is not null or undefined
            assertParamExists('log', 'logRequestBody', logRequestBody)
            const localVarPath = `/v1/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteOne: async (objectId: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesDeleteOne', 'objectId', objectId)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesDeleteSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('outagesDeleteSome', 'ids', ids)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetOne: async (objectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesGetOne', 'objectId', objectId)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesGetSome: async (ids: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('outagesGetSome', 'ids', ids)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Post One
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostOne: async (outage: Outage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPostOne', 'outage', outage)
            const localVarPath = `/v1/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostQuery: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('outagesPostQuery', 'filter', filter)
            const localVarPath = `/v1/outages/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostQueryIds: async (filter: EpiFilter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filter' is not null or undefined
            assertParamExists('outagesPostQueryIds', 'filter', filter)
            const localVarPath = `/v1/outages/query/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Post Some
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPostSome: async (outage: Array<Outage>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPostSome', 'outage', outage)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Put One
         * @param {string} objectId 
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPutOne: async (objectId: string, outage: Outage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('outagesPutOne', 'objectId', objectId)
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPutOne', 'outage', outage)
            const localVarPath = `/v1/outages/{object_id}`
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages  Put Some
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        outagesPutSome: async (outage: Array<Outage>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outage' is not null or undefined
            assertParamExists('outagesPutSome', 'outage', outage)
            const localVarPath = `/v1/outages/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Licenses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveLicenses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOutages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/retrieve/outages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the health status of the service. If no response is received within the timeout period, the service is considered unhealthy.
         * @summary Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthReponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs the provided log items.
         * @summary Log
         * @param {LogRequestBody} logRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async log(logRequestBody: LogRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.log(logRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.log']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Delete All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Delete One
         * @param {any} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteOne(objectId: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Delete Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesDeleteSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesDeleteSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesDeleteSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Get All
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesGetAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Get One
         * @param {string} objectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetOne(objectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetOne(objectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Get Some
         * @param {string} ids 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesGetSome(ids: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesGetSome(ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesGetSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Post One
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostOne(outage: Outage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostOne(outage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPostOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Post Query
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostQuery(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPostQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Post Query  Ids
         * @param {EpiFilter} filter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostQueryIds(filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPostQueryIds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Post Some
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPostSome(outage: Array<Outage>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPostSome(outage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPostSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Put One
         * @param {string} objectId 
         * @param {Outage} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPutOne(objectId: string, outage: Outage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Outage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPutOne(objectId, outage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPutOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages  Put Some
         * @param {Array<Outage>} outage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async outagesPutSome(outage: Array<Outage>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.outagesPutSome(outage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.outagesPutSome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Licenses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveLicenses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackageMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveLicenses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.retrieveLicenses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Outages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOutages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Outage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOutages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.retrieveOutages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */

/**
 * SystemApi - object-oriented interface

 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
  private static __instance: SystemApi;
  public static get instance(): SystemApi {
    SystemApi.__instance = SystemApi.__instance || new SystemApi();
    return SystemApi.__instance;
  }

    /**
     * Returns the health status of the service. If no response is received within the timeout period, the service is considered unhealthy.
     * @summary Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public health(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).health(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * Logs the provided log items.
     * @summary Log
     * @param {LogRequestBody} logRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public log(logRequestBody: LogRequestBody, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).log(logRequestBody, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Delete All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteAll(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Delete One
     * @param {any} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteOne(objectId: any, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Delete Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesDeleteSome(ids: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesDeleteSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Get All
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetAll(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetAll(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Get One
     * @param {string} objectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetOne(objectId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetOne(objectId, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Get Some
     * @param {string} ids 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesGetSome(ids: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesGetSome(ids, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Post One
     * @param {Outage} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostOne(outage: Outage, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostOne(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Post Query
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostQuery(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostQuery(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Post Query  Ids
     * @param {EpiFilter} filter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostQueryIds(filter: EpiFilter, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostQueryIds(filter, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Post Some
     * @param {Array<Outage>} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPostSome(outage: Array<Outage>, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPostSome(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Put One
     * @param {string} objectId 
     * @param {Outage} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPutOne(objectId: string, outage: Outage, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPutOne(objectId, outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages  Put Some
     * @param {Array<Outage>} outage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public outagesPutSome(outage: Array<Outage>, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).outagesPutSome(outage, options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Licenses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public retrieveLicenses(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).retrieveLicenses(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }

    /**
     * 
     * @summary Outages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public retrieveOutages(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).retrieveOutages(options).then((request) => request(this.axios, this.configuration.baseUrl));
    }
}



